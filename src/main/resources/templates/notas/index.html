<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Anota√ß√µes - Notisblokk</title>
    <link rel="stylesheet" href="/css/notas.css">
</head>
<body>
    <th:block th:replace="~{layout/base :: base(~{::main-content})}">
        <div th:fragment="main-content" x-data="notasApp()">
            <!-- Container de Toast Notifications -->
            <div id="toast-container" class="toast-container"></div>
            <!-- Cabe√ßalho e A√ß√µes -->
            <div class="header-compact">
                <h1 class="page-title">üìù Anota√ß√µes</h1>
                <div class="acoes-topo">
                    <a href="/notas/nova" class="btn btn-primary btn-sm">
                        ‚ûï Nova Nota
                    </a>
                    <!-- Contador e bot√£o de exporta√ß√£o em massa -->
                    <div x-show="notasSelecionadas.length > 0" class="badge badge-info" style="padding: 0.5rem 1rem; font-size: 0.9rem;">
                        ‚úì <span x-text="notasSelecionadas.length"></span> selecionada(s)
                    </div>
                    <button
                        x-show="notasSelecionadas.length > 0"
                        @click="exportarSelecionadas()"
                        class="btn btn-success btn-sm"
                        title="Exportar notas selecionadas para PDF">
                        üìä Exportar Selecionadas (<span x-text="notasSelecionadas.length"></span>)
                    </button>
                    <button @click="abrirModalAlertas()" class="btn btn-sm btn-alertas" :class="{'btn-danger': alertasUrgentes.length > 0, 'btn-warning': alertasUrgentes.length === 0, 'pulse-animation': temAlertasCriticos()}">
                        üîî Alertas
                        <span x-show="alertasUrgentes.length > 0" class="badge-counter" x-text="alertasUrgentes.length"></span>
                    </button>
                    <button @click="abrirModalEtiquetas()" class="btn btn-secondary btn-sm">
                        üè∑Ô∏è Etiquetas
                    </button>
                    <button @click="abrirModalStatus()" class="btn btn-secondary btn-sm">
                        üìä Status
                    </button>
                </div>
            </div>

            <!-- Filtros e Pesquisa Unificados -->
            <div class="card mb-2">
                <div class="card-body-compact">
                    <div class="filtros-pesquisa-row">
                        <input
                            type="text"
                            x-model="termoPesquisa"
                            @input="pesquisarNotas()"
                            placeholder="üîç Pesquisar..."
                            class="form-control-compact search-compact"
                        >
                        <select id="filtroEtiqueta" class="form-control-compact">
                            <option value="">Todas as etiquetas</option>
                        </select>
                        <select id="filtroStatus" class="form-control-compact">
                            <option value="">Todos os status</option>
                        </select>
                        <button @click="mostrarControlesColunas = !mostrarControlesColunas" class="btn btn-secondary btn-icon" title="Configurar colunas">
                            ‚öôÔ∏è
                        </button>
                    </div>

                    <!-- Controles de Colunas -->
                    <div x-show="mostrarControlesColunas" class="column-controls-compact">
                        <label class="column-toggle-compact">
                            <input type="checkbox" x-model="colunasVisiveis.titulo"> T√≠tulo
                        </label>
                        <label class="column-toggle-compact">
                            <input type="checkbox" x-model="colunasVisiveis.etiqueta"> Etiqueta
                        </label>
                        <label class="column-toggle-compact">
                            <input type="checkbox" x-model="colunasVisiveis.status"> Status
                        </label>
                        <label class="column-toggle-compact">
                            <input type="checkbox" x-model="colunasVisiveis.prazo"> Prazo
                        </label>
                        <label class="column-toggle-compact">
                            <input type="checkbox" x-model="colunasVisiveis.diasRestantes"> Dias Rest.
                        </label>
                    </div>
                </div>
            </div>

            <!-- Tabela de Notas -->
            <div class="card">
                <div class="table-responsive">
                    <table class="notas-table">
                        <thead>
                            <tr>
                                <!-- Coluna de sele√ß√£o m√∫ltipla -->
                                <th style="width: 40px; text-align: center;">
                                    <input
                                        type="checkbox"
                                        @change="toggleSelecionarTodas()"
                                        :checked="todasNotasSelecionadas()"
                                        title="Selecionar/Desselecionar todas"
                                    >
                                </th>
                                <th x-show="colunasVisiveis.titulo" @click="ordenarPor('titulo')" class="sortable">
                                    T√≠tulo <span x-text="getSortIcon('titulo')"></span>
                                </th>
                                <th x-show="colunasVisiveis.etiqueta" @click="ordenarPor('etiqueta')" class="sortable">
                                    Etiqueta <span x-text="getSortIcon('etiqueta')"></span>
                                </th>
                                <th x-show="colunasVisiveis.status" @click="ordenarPor('status')" class="sortable">
                                    Status <span x-text="getSortIcon('status')"></span>
                                </th>
                                <th x-show="colunasVisiveis.prazo" @click="ordenarPor('prazo')" class="sortable">
                                    Prazo <span x-text="getSortIcon('prazo')"></span>
                                </th>
                                <th x-show="colunasVisiveis.diasRestantes" @click="ordenarPor('diasRestantes')" class="sortable">
                                    Dias Restantes <span x-text="getSortIcon('diasRestantes')"></span>
                                </th>
                                <th class="acoes-col">A√ß√µes</th>
                            </tr>
                        </thead>
                        <tbody>
                            <template x-for="nota in notasProcessadas" :key="nota.id">
                                <tr :class="{'nota-atrasada': nota.diasRestantes < 0, 'nota-urgente': nota.diasRestantes >= 0 && nota.diasRestantes <= 3}">
                                    <!-- Checkbox de sele√ß√£o -->
                                    <td style="width: 40px; text-align: center;">
                                        <input
                                            type="checkbox"
                                            :value="nota.id"
                                            @change="toggleSelecaoNota(nota.id)"
                                            :checked="notaEstaSelecionada(nota.id)"
                                        >
                                    </td>
                                    <td x-show="colunasVisiveis.titulo">
                                        <strong @click="visualizarNota(nota.id)" style="cursor: pointer; color: var(--color-primary); text-decoration: underline;" x-text="nota.titulo"></strong>
                                    </td>
                                    <td x-show="colunasVisiveis.etiqueta">
                                        <span class="badge" :style="'background-color: ' + (nota.etiqueta.corHex || '#6B7280') + '; color: ' + getContrastColor(nota.etiqueta.corHex || '#6B7280')" x-text="nota.etiqueta.nome"></span>
                                    </td>
                                    <td x-show="colunasVisiveis.status">
                                        <span class="badge" :style="'background-color: ' + nota.status.corHex + '; color: ' + getContrastColor(nota.status.corHex)" x-text="nota.status.nome"></span>
                                    </td>
                                    <td x-show="colunasVisiveis.prazo" x-text="nota.prazoFinal"></td>
                                    <td x-show="colunasVisiveis.diasRestantes">
                                        <span class="badge" :class="getBadgeClass(nota.diasRestantes)" x-text="getDiasPrazoText(nota)"></span>
                                    </td>
                                    <td class="acoes-col">
                                        <div class="btn-group">
                                            <a :href="'/notas/editar/' + nota.id" class="btn btn-sm btn-primary" title="Editar">‚úèÔ∏è</a>
                                            <!-- Bot√£o para exportar nota individual em PDF -->
                                            <button @click="gerarPDF(nota.id, nota.titulo)" class="btn btn-sm btn-success" title="Exportar PDF">üìÑ</button>
                                            <button @click="deletarNota(nota.id)" class="btn btn-sm btn-danger" title="Deletar">üóëÔ∏è</button>
                                        </div>
                                    </td>
                                </tr>
                            </template>
                        </tbody>
                    </table>

                    <div x-show="notasProcessadas.length === 0" class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <p>Nenhuma nota encontrada</p>
                    </div>
                </div>
            </div>

            <!-- Modal Etiquetas -->
            <div class="modal-overlay" :class="{ active: modalEtiquetas }">
                <div class="modal modal-large">
                    <div class="modal-header">
                        <h2 class="modal-title">Gerenciar Etiquetas</h2>
                        <button @click="fecharModalEtiquetas()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form @submit.prevent="salvarEtiqueta()" class="mb-3">
                            <div class="d-flex gap-2">
                                <input type="text" x-model="novaEtiqueta" placeholder="Nome da etiqueta" class="form-input" required>
                                <button type="submit" class="btn btn-primary" x-text="etiquetaEditandoId ? 'Salvar' : 'Adicionar'"></button>
                                <button type="button" x-show="etiquetaEditandoId" @click="cancelarEdicaoEtiqueta()" class="btn btn-secondary">Cancelar</button>
                            </div>
                        </form>
                        <div class="item-list">
                            <template x-for="etiqueta in etiquetas" :key="etiqueta.id">
                                <div class="item-list-row">
                                    <span x-text="etiqueta.nome + ' (' + etiqueta.totalNotas + ' notas)'"></span>
                                    <div class="btn-group">
                                        <button @click="iniciarEdicaoEtiqueta(etiqueta)" class="btn btn-sm btn-secondary" title="Editar">‚úèÔ∏è</button>
                                        <button @click="deletarEtiqueta(etiqueta.id)" class="btn btn-sm btn-danger" title="Deletar">üóëÔ∏è</button>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="fecharModalEtiquetas()" class="btn btn-secondary">Fechar</button>
                    </div>
                </div>
            </div>

            <!-- Modal Status -->
            <div class="modal-overlay" :class="{ active: modalStatus }">
                <div class="modal modal-large">
                    <div class="modal-header">
                        <h2 class="modal-title">Gerenciar Status</h2>
                        <button @click="fecharModalStatus()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form @submit.prevent="salvarStatus()" class="mb-3">
                            <div class="d-flex gap-2" style="align-items: center;">
                                <input type="text" x-model="novoStatus.nome" placeholder="Nome do status" class="form-input" required>
                                <input type="color" x-model="novoStatus.cor" class="form-control" style="width: 80px; height: 40px; padding: 2px;" required>
                                <div class="color-indicator" :style="'background-color: ' + novoStatus.cor" style="width: 40px; height: 40px;"></div>
                                <button type="submit" class="btn btn-primary" x-text="statusEditandoId ? 'Salvar' : 'Adicionar'"></button>
                                <button type="button" x-show="statusEditandoId" @click="cancelarEdicaoStatus()" class="btn btn-secondary">Cancelar</button>
                            </div>
                        </form>
                        <div class="item-list">
                            <template x-for="status in statusList" :key="status.id">
                                <div class="item-list-row">
                                    <div class="d-flex gap-2 align-items-center">
                                        <div class="color-indicator" :style="'background-color: ' + status.corHex"></div>
                                        <span x-text="status.nome"></span>
                                    </div>
                                    <div class="btn-group">
                                        <button @click="iniciarEdicaoStatus(status)" class="btn btn-sm btn-secondary" title="Editar">‚úèÔ∏è</button>
                                        <button @click="deletarStatus(status.id)" class="btn btn-sm btn-danger" title="Deletar">üóëÔ∏è</button>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="fecharModalStatus()" class="btn btn-secondary">Fechar</button>
                    </div>
                </div>
            </div>

            <!-- Modal Preview de Nota -->
            <div class="modal-overlay" :class="{ active: modalPreview }">
                <div class="modal modal-large">
                    <div class="modal-header">
                        <h2 class="modal-title">üëÅÔ∏è Visualizar Nota</h2>
                        <button @click="fecharModalPreview()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body" x-show="notaPreview">
                        <!-- T√≠tulo da Nota -->
                        <h3 class="nota-preview-titulo" x-text="notaPreview?.titulo"></h3>

                        <!-- Metadados -->
                        <div class="nota-preview-meta">
                            <div class="meta-item">
                                <strong>Etiqueta:</strong>
                                <span class="badge" :style="'background-color: ' + (notaPreview?.etiqueta?.corHex || '#6B7280') + '; color: ' + getContrastColor(notaPreview?.etiqueta?.corHex || '#6B7280')" x-text="notaPreview?.etiqueta?.nome"></span>
                            </div>
                            <div class="meta-item">
                                <strong>Status:</strong>
                                <span class="badge" :style="'background-color: ' + (notaPreview?.status?.corHex || '#6B7280') + '; color: ' + getContrastColor(notaPreview?.status?.corHex || '#6B7280')" x-text="notaPreview?.status?.nome"></span>
                            </div>
                            <div class="meta-item">
                                <strong>Prazo Final:</strong>
                                <span x-text="notaPreview?.prazoFinal"></span>
                            </div>
                        </div>

                        <!-- Conte√∫do da Nota -->
                        <div class="nota-preview-conteudo">
                            <h4>Conte√∫do:</h4>
                            <div class="ql-editor" x-html="notaPreview?.conteudo || '<p>Sem conte√∫do</p>'"></div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="exportarPDFPreview()" class="btn btn-success">
                            üìÑ Exportar PDF
                        </button>
                        <a :href="'/notas/editar/' + notaPreview?.id" class="btn btn-primary">
                            ‚úèÔ∏è Editar
                        </a>
                        <button @click="fecharModalPreview()" class="btn btn-secondary">Fechar</button>
                    </div>
                </div>
            </div>

            <!-- Modal Confirmar Exclus√£o -->
            <div class="modal-overlay" :class="{ active: modalConfirmarDeletar }">
                <div class="modal modal-confirm-delete">
                    <div class="modal-header modal-header-danger">
                        <h2 class="modal-title">‚ö†Ô∏è Confirmar Exclus√£o</h2>
                        <button @click="cancelarDeletar()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>Tem certeza que deseja deletar a seguinte nota?</p>
                        <div class="nota-deletar-info" x-show="notaDeletar">
                            <strong x-text="notaDeletar?.titulo"></strong>
                        </div>
                        <p class="text-danger">‚ö†Ô∏è Esta a√ß√£o n√£o pode ser desfeita!</p>
                    </div>
                    <div class="modal-footer modal-footer-danger">
                        <button @click="cancelarDeletar()" class="btn btn-secondary">
                            ‚úï Cancelar
                        </button>
                        <button @click="confirmarDeletar()" class="btn btn-danger">
                            üóëÔ∏è Deletar Permanentemente
                        </button>
                    </div>
                </div>
            </div>

            <!-- Modal Alertas -->
            <div class="modal-overlay" :class="{ active: modalAlertas }">
                <div class="modal modal-large">
                    <div class="modal-header">
                        <h2 class="modal-title">üîî Alertas de Anota√ß√µes</h2>
                        <button @click="fecharModalAlertas()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body" style="max-height: 600px; overflow-y: auto;">
                        <div x-show="alertasUrgentes.length === 0" class="empty-state">
                            <div class="empty-state-icon">‚úÖ</div>
                            <p>Nenhum alerta urgente no momento!</p>
                        </div>

                        <div x-show="alertasUrgentes.length > 0" style="display: flex; flex-direction: column; gap: 0.75rem;">
                            <template x-for="alerta in alertasUrgentes" :key="alerta.id">
                                <div class="alerta-card" :class="'alerta-' + alerta.nivel.toLowerCase()">
                                    <div class="alerta-card-header">
                                        <span class="alerta-icon-grande" x-text="getAlertaIcon(alerta.nivel)"></span>
                                        <span class="alerta-nivel-badge" x-text="alerta.nivel"></span>
                                    </div>
                                    <div class="alerta-card-body">
                                        <h3 class="alerta-titulo" x-text="alerta.titulo"></h3>
                                        <div class="alerta-prazo-info">
                                            <strong>Prazo:</strong> <span x-text="alerta.prazoTexto"></span>
                                        </div>
                                    </div>
                                    <div class="alerta-card-footer">
                                        <a :href="'/notas/editar/' + alerta.id" class="btn btn-sm btn-primary">
                                            Ver Anota√ß√£o ‚Üí
                                        </a>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="fecharModalAlertas()" class="btn btn-secondary">Fechar</button>
                    </div>
                </div>
            </div>

            <script>
                /**
                 * Sistema de Toast Notifications
                 * @param {string} tipo - Tipo do toast: 'success', 'error', 'warning', 'info'
                 * @param {string} titulo - T√≠tulo da notifica√ß√£o
                 * @param {string} mensagem - Mensagem detalhada (opcional)
                 * @param {number} duracao - Dura√ß√£o em ms (padr√£o: 4000ms)
                 */
                function mostrarToast(tipo, titulo, mensagem = '', duracao = 4000) {
                    const container = document.getElementById('toast-container');
                    if (!container) {
                        console.error('Container de toasts n√£o encontrado');
                        return;
                    }

                    // Mapear √≠cones por tipo
                    const icones = {
                        success: '‚úì',
                        error: '‚úï',
                        warning: '‚ö†',
                        info: '‚Ñπ'
                    };

                    // Criar elemento do toast
                    const toast = document.createElement('div');
                    toast.className = `toast toast-${tipo}`;
                    toast.innerHTML = `
                        <div class="toast-icon">${icones[tipo] || '‚Ñπ'}</div>
                        <div class="toast-content">
                            <div class="toast-title">${titulo}</div>
                            ${mensagem ? `<div class="toast-message">${mensagem}</div>` : ''}
                        </div>
                        <button class="toast-close" aria-label="Fechar">&times;</button>
                    `;

                    // Adicionar ao container
                    container.appendChild(toast);

                    // Bot√£o de fechar
                    const closeBtn = toast.querySelector('.toast-close');
                    closeBtn.addEventListener('click', () => {
                        removerToast(toast);
                    });

                    // Auto-remover ap√≥s dura√ß√£o
                    setTimeout(() => {
                        removerToast(toast);
                    }, duracao);

                    // Log para debugging
                    console.log(`üîî Toast [${tipo}]: ${titulo}${mensagem ? ' - ' + mensagem : ''}`);
                }

                /**
                 * Remove um toast com anima√ß√£o
                 * @param {HTMLElement} toast - Elemento do toast a ser removido
                 */
                function removerToast(toast) {
                    toast.classList.add('toast-hiding');
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }

                function notasApp() {
                    return {
                        notas: [],
                        notasFiltradas: [],
                        notasProcessadas: [],
                        alertasUrgentes: [],
                        etiquetas: [],
                        statusList: [],
                        modalEtiquetas: false,
                        modalStatus: false,
                        modalAlertas: false,
                        modalPreview: false,
                        notaPreview: null,
                        modalConfirmarDeletar: false,
                        notaDeletar: null,
                        novaEtiqueta: '',
                        novoStatus: { nome: '', cor: '#6B7280' },
                        etiquetaEditandoId: null,
                        statusEditandoId: null,
                        filtroEtiqueta: '',
                        filtroStatus: '',
                        termoPesquisa: '',
                        mostrarControlesColunas: false,
                        colunaOrdenacao: 'diasRestantes',
                        direcaoOrdenacao: 'asc',
                        colunasVisiveis: {
                            titulo: true,
                            etiqueta: true,
                            status: true,
                            prazo: true,
                            diasRestantes: true
                        },
                        pesquisaTimeout: null,
                        // Sele√ß√£o m√∫ltipla de notas para exporta√ß√£o em massa
                        notasSelecionadas: [],

                        async init() {
                            // Carregar prefer√™ncias de colunas do localStorage
                            const colunasSalvas = localStorage.getItem('notasColunasVisiveis');
                            if (colunasSalvas) {
                                this.colunasVisiveis = JSON.parse(colunasSalvas);
                            }

                            await this.carregarEtiquetas();
                            await this.carregarStatus();
                            await this.carregarNotas();
                            // Alertas s√£o gerados automaticamente em processarNotas()

                            // Adicionar event listeners para os filtros
                            document.getElementById('filtroEtiqueta').addEventListener('change', (e) => {
                                this.filtroEtiqueta = e.target.value;
                                this.processarNotas();
                            });

                            document.getElementById('filtroStatus').addEventListener('change', (e) => {
                                this.filtroStatus = e.target.value;
                                this.processarNotas();
                            });

                            // Watch para salvar prefer√™ncias de colunas
                            this.$watch('colunasVisiveis', (value) => {
                                localStorage.setItem('notasColunasVisiveis', JSON.stringify(value));
                            });
                        },

                        async carregarNotas() {
                            try {
                                const url = '/api/notas';
                                console.log('Carregando notas de:', url);
                                const res = await fetch(url);
                                console.log('Status da resposta:', res.status);
                                const data = await res.json();
                                console.log('Dados recebidos:', data);

                                if (!data.success) {
                                    console.error('Erro da API:', data.message || data.error);
                                    mostrarToast('error', 'Erro ao Carregar', data.message || data.error || 'N√£o foi poss√≠vel carregar as notas');
                                    return;
                                }

                                this.notas = data.dados || [];
                                console.log(`‚úì ${this.notas.length} nota(s) carregada(s):`, this.notas);
                                this.processarNotas();
                            } catch (err) {
                                console.error('Erro ao carregar notas:', err);
                                mostrarToast('error', 'Erro ao Carregar', 'Ocorreu um erro ao carregar as notas');
                            }
                        },

                        // Processa e filtra notas
                        processarNotas() {
                            console.log('üîÑ Processando notas...');

                            // 1. Calcular dias restantes para cada nota
                            const notasComDias = this.notas.map(nota => {
                                const prazo = this.parseDataBrasileira(nota.prazoFinal);
                                const hoje = new Date();
                                hoje.setHours(0, 0, 0, 0);
                                const diasRestantes = Math.floor((prazo - hoje) / (1000 * 60 * 60 * 24));

                                console.log(`üìÖ Nota "${nota.titulo}": prazoFinal="${nota.prazoFinal}", prazoDate=${prazo}, diasRestantes=${diasRestantes}`);

                                return {
                                    ...nota,
                                    diasRestantes,
                                    prazoDate: prazo
                                };
                            });

                            // 2. Filtrar por pesquisa
                            let notasFiltradas = notasComDias;
                            if (this.termoPesquisa.trim()) {
                                const termo = this.termoPesquisa.toLowerCase();
                                notasFiltradas = notasFiltradas.filter(nota =>
                                    nota.titulo.toLowerCase().includes(termo) ||
                                    (nota.conteudo && nota.conteudo.toLowerCase().includes(termo)) ||
                                    nota.etiqueta.nome.toLowerCase().includes(termo) ||
                                    nota.status.nome.toLowerCase().includes(termo)
                                );
                            }

                            // 3. Filtrar por etiqueta
                            if (this.filtroEtiqueta) {
                                notasFiltradas = notasFiltradas.filter(n => n.etiqueta.id == this.filtroEtiqueta);
                            }

                            // 4. Filtrar por status
                            if (this.filtroStatus) {
                                notasFiltradas = notasFiltradas.filter(n => n.status.id == this.filtroStatus);
                            }

                            // 5. Ordenar
                            notasFiltradas.sort((a, b) => {
                                let valorA, valorB;

                                switch(this.colunaOrdenacao) {
                                    case 'titulo':
                                        valorA = a.titulo.toLowerCase();
                                        valorB = b.titulo.toLowerCase();
                                        break;
                                    case 'etiqueta':
                                        valorA = a.etiqueta.nome.toLowerCase();
                                        valorB = b.etiqueta.nome.toLowerCase();
                                        break;
                                    case 'status':
                                        valorA = a.status.nome.toLowerCase();
                                        valorB = b.status.nome.toLowerCase();
                                        break;
                                    case 'prazo':
                                        valorA = a.prazoDate.getTime();
                                        valorB = b.prazoDate.getTime();
                                        break;
                                    case 'diasRestantes':
                                    default:
                                        valorA = a.diasRestantes;
                                        valorB = b.diasRestantes;
                                        break;
                                }

                                if (valorA < valorB) return this.direcaoOrdenacao === 'asc' ? -1 : 1;
                                if (valorA > valorB) return this.direcaoOrdenacao === 'asc' ? 1 : -1;
                                return 0;
                            });

                            this.notasProcessadas = notasFiltradas;

                            // 6. Gerar alertas urgentes
                            this.gerarAlertasUrgentes(notasComDias);
                        },

                        // Gera lista de alertas por prioridade
                        gerarAlertasUrgentes(notas) {
                            const alertas = [];

                            notas.forEach(nota => {
                                // Ignorar notas com status "Resolvido" ou "Cancelado"
                                const statusNome = nota.status?.nome?.toLowerCase() || '';
                                if (statusNome === 'resolvido' || statusNome === 'cancelado') {
                                    return; // N√£o gera alerta para essas notas
                                }

                                let nivel, prazoTexto;
                                const dias = nota.diasRestantes;

                                if (dias < 0) {
                                    nivel = 'CR√çTICO';
                                    prazoTexto = `Atrasada ${Math.abs(dias)} dia(s)`;
                                } else if (dias === 0) {
                                    nivel = 'CR√çTICO';
                                    prazoTexto = 'Vence HOJE';
                                } else if (dias === 1) {
                                    nivel = 'URGENTE';
                                    prazoTexto = 'Vence AMANH√É';
                                } else if (dias <= 3) {
                                    nivel = 'URGENTE';
                                    prazoTexto = `${dias} dias restantes`;
                                } else if (dias <= 5) {
                                    nivel = 'ATEN√á√ÉO';
                                    prazoTexto = `${dias} dias restantes`;
                                } else if (dias <= 7) {
                                    nivel = 'AVISO';
                                    prazoTexto = `${dias} dias restantes`;
                                } else {
                                    return; // N√£o inclui em alertas
                                }

                                alertas.push({
                                    id: nota.id,
                                    titulo: nota.titulo,
                                    nivel,
                                    prazoTexto,
                                    diasRestantes: dias
                                });
                            });

                            // Ordenar por urg√™ncia (dias restantes crescente)
                            alertas.sort((a, b) => a.diasRestantes - b.diasRestantes);

                            this.alertasUrgentes = alertas;
                            console.log(`üö® ${alertas.length} alerta(s) gerado(s):`, alertas);
                        },

                        // Parse data brasileira (dd/MM/yyyy, dd-MM-yyyy) ou ISO (yyyy-MM-dd)
                        parseDataBrasileira(dataStr) {
                            if (!dataStr) return new Date();

                            // Verifica se √© formato ISO (yyyy-MM-dd)
                            if (dataStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                                const partes = dataStr.split('-');
                                return new Date(partes[0], partes[1] - 1, partes[2]);
                            }

                            // Formato brasileiro com barras (dd/MM/yyyy)
                            if (dataStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                                const partes = dataStr.split('/');
                                return new Date(partes[2], partes[1] - 1, partes[0]);
                            }

                            // Formato brasileiro com h√≠fens (dd-MM-yyyy)
                            if (dataStr.match(/^\d{2}-\d{2}-\d{4}$/)) {
                                const partes = dataStr.split('-');
                                return new Date(partes[2], partes[1] - 1, partes[0]);
                            }

                            // Fallback: tenta criar Date diretamente
                            console.warn('Formato de data n√£o reconhecido:', dataStr);
                            return new Date(dataStr);
                        },

                        // Pesquisa com debounce
                        pesquisarNotas() {
                            clearTimeout(this.pesquisaTimeout);
                            this.pesquisaTimeout = setTimeout(() => {
                                this.processarNotas();
                            }, 300);
                        },

                        // Ordenar por coluna
                        ordenarPor(coluna) {
                            if (this.colunaOrdenacao === coluna) {
                                // Inverte dire√ß√£o se j√° est√° ordenando por essa coluna
                                this.direcaoOrdenacao = this.direcaoOrdenacao === 'asc' ? 'desc' : 'asc';
                            } else {
                                // Nova coluna, come√ßa com ascendente
                                this.colunaOrdenacao = coluna;
                                this.direcaoOrdenacao = 'asc';
                            }
                            this.processarNotas();
                        },

                        // √çcone de ordena√ß√£o
                        getSortIcon(coluna) {
                            if (this.colunaOrdenacao !== coluna) return '‚áÖ';
                            return this.direcaoOrdenacao === 'asc' ? '‚Üë' : '‚Üì';
                        },

                        // √çcone de alerta
                        getAlertaIcon(nivel) {
                            switch(nivel) {
                                case 'CR√çTICO': return 'üî¥';
                                case 'URGENTE': return 'üü†';
                                case 'ATEN√á√ÉO': return 'üü°';
                                case 'AVISO': return 'üîµ';
                                default: return '‚ö™';
                            }
                        },

                        async carregarEtiquetas() {
                            try {
                                const res = await fetch('/api/etiquetas');
                                const data = await res.json();
                                this.etiquetas = data.dados || [];

                                // Popular select de filtro
                                const selectFiltro = document.getElementById('filtroEtiqueta');
                                selectFiltro.innerHTML = '<option value="">Todas as etiquetas</option>';
                                this.etiquetas.forEach(etiqueta => {
                                    const option = document.createElement('option');
                                    option.value = etiqueta.id;
                                    option.textContent = etiqueta.nome;
                                    selectFiltro.appendChild(option);
                                });
                            } catch (err) {
                                console.error('Erro ao carregar etiquetas:', err);
                            }
                        },

                        async carregarStatus() {
                            try {
                                const res = await fetch('/api/status');
                                const data = await res.json();

                                console.log('Status carregados:', data);

                                if (!data.success) {
                                    console.error('Erro ao carregar status:', data.message);
                                    mostrarToast('error', 'Erro ao Carregar Status', data.message || 'N√£o foi poss√≠vel carregar os status');
                                    return;
                                }

                                this.statusList = data.dados || [];

                                if (this.statusList.length === 0) {
                                    console.warn('Nenhum status encontrado no banco de dados');
                                    return;
                                }

                                // Popular select de filtro
                                const selectFiltro = document.getElementById('filtroStatus');
                                selectFiltro.innerHTML = '<option value="">Todos os status</option>';
                                this.statusList.forEach(status => {
                                    const option = document.createElement('option');
                                    option.value = status.id;
                                    option.textContent = status.nome;
                                    selectFiltro.appendChild(option);
                                });

                                console.log(`‚úì ${this.statusList.length} status carregados com sucesso`);
                            } catch (err) {
                                console.error('Erro ao carregar status:', err);
                                mostrarToast('error', 'Erro ao Carregar Status', 'Ocorreu um erro ao carregar os status');
                            }
                        },

                        // Alertas agora s√£o gerados localmente pela fun√ß√£o gerarAlertasUrgentes()
                        // que √© chamada automaticamente ao processar as notas

                        /**
                         * Abre modal de confirma√ß√£o para deletar nota
                         * @param {number} id - ID da nota a ser deletada
                         */
                        deletarNota(id) {
                            // Buscar a nota na lista processada
                            const nota = this.notasProcessadas.find(n => n.id === id);
                            if (nota) {
                                this.notaDeletar = nota;
                                this.modalConfirmarDeletar = true;
                            }
                        },

                        /**
                         * Confirma e executa a exclus√£o da nota
                         */
                        async confirmarDeletar() {
                            if (!this.notaDeletar) return;

                            const id = this.notaDeletar.id;
                            const titulo = this.notaDeletar.titulo;

                            try {
                                const res = await fetch(`/api/notas/${id}`, { method: 'DELETE' });
                                const data = await res.json();

                                if (data.success) {
                                    mostrarToast('success', 'Nota Deletada', `"${titulo}" foi removida com sucesso!`);
                                    await this.carregarNotas();
                                } else {
                                    mostrarToast('error', 'Erro ao Deletar', data.message || 'N√£o foi poss√≠vel deletar a nota');
                                }
                            } catch (err) {
                                mostrarToast('error', 'Erro ao Deletar', 'Ocorreu um erro ao tentar deletar a nota');
                                console.error('Erro ao deletar nota:', err);
                            } finally {
                                // Fechar modal
                                this.cancelarDeletar();
                            }
                        },

                        /**
                         * Cancela a exclus√£o e fecha o modal
                         */
                        cancelarDeletar() {
                            this.modalConfirmarDeletar = false;
                            setTimeout(() => {
                                this.notaDeletar = null;
                            }, 300);
                        },

                        /**
                         * Exporta uma nota individual para PDF
                         * @param {number} notaId - ID da nota a ser exportada
                         * @param {string} tituloNota - T√≠tulo da nota (usado para nome do arquivo)
                         */
                        async gerarPDF(notaId, tituloNota) {
                            try {
                                console.log(`üìÑ Gerando PDF para nota ID: ${notaId}`);

                                // Fazer requisi√ß√£o para o endpoint de PDF
                                const response = await fetch(`/api/notas/${notaId}/pdf`);

                                if (!response.ok) {
                                    throw new Error(`Erro ao gerar PDF: ${response.statusText}`);
                                }

                                // Converter resposta em blob
                                const blob = await response.blob();

                                // Criar nome do arquivo limpo (sem caracteres especiais)
                                const nomeArquivo = tituloNota
                                    .replace(/[^a-zA-Z0-9\s-]/g, '') // Remove caracteres especiais
                                    .replace(/\s+/g, '_') // Substitui espa√ßos por underscore
                                    .substring(0, 50); // Limita tamanho

                                // Gerar timestamp no formato brasileiro (DDMMYYYY)
                                const agora = new Date();
                                const dia = String(agora.getDate()).padStart(2, '0');
                                const mes = String(agora.getMonth() + 1).padStart(2, '0');
                                const ano = agora.getFullYear();
                                const timestamp = `${dia}${mes}${ano}`;

                                const nomeCompleto = `Nota_${nomeArquivo}_${timestamp}.pdf`;

                                // Criar link tempor√°rio para download
                                const url = window.URL.createObjectURL(blob);
                                const link = document.createElement('a');
                                link.href = url;
                                link.download = nomeCompleto;
                                document.body.appendChild(link);
                                link.click();

                                // Limpar
                                document.body.removeChild(link);
                                window.URL.revokeObjectURL(url);

                                console.log(`‚úì PDF gerado com sucesso: ${nomeCompleto}`);

                                // Feedback visual com toast
                                mostrarToast('success', 'PDF Exportado', 'Nota exportada com sucesso!');

                            } catch (error) {
                                console.error('‚ùå Erro ao gerar PDF:', error);
                                mostrarToast('error', 'Erro ao Exportar', `N√£o foi poss√≠vel gerar o PDF: ${error.message}`);
                            }
                        },

                        /**
                         * Alterna a sele√ß√£o de uma nota individual
                         * @param {number} notaId - ID da nota a ser selecionada/desselecionada
                         */
                        toggleSelecaoNota(notaId) {
                            const index = this.notasSelecionadas.indexOf(notaId);
                            if (index === -1) {
                                // Nota n√£o est√° selecionada, adicionar
                                this.notasSelecionadas.push(notaId);
                                console.log(`‚úì Nota ${notaId} selecionada. Total: ${this.notasSelecionadas.length}`);
                            } else {
                                // Nota j√° est√° selecionada, remover
                                this.notasSelecionadas.splice(index, 1);
                                console.log(`‚úó Nota ${notaId} desselecionada. Total: ${this.notasSelecionadas.length}`);
                            }
                        },

                        /**
                         * Verifica se uma nota est√° selecionada
                         * @param {number} notaId - ID da nota
                         * @returns {boolean} true se a nota est√° selecionada
                         */
                        notaEstaSelecionada(notaId) {
                            return this.notasSelecionadas.includes(notaId);
                        },

                        /**
                         * Alterna entre selecionar todas as notas vis√≠veis ou desselecionar todas
                         */
                        toggleSelecionarTodas() {
                            if (this.todasNotasSelecionadas()) {
                                // Desselecionar todas
                                this.notasSelecionadas = [];
                                console.log('‚úó Todas as notas desselecionadas');
                            } else {
                                // Selecionar todas as notas vis√≠veis (processadas)
                                this.notasSelecionadas = this.notasProcessadas.map(nota => nota.id);
                                console.log(`‚úì ${this.notasSelecionadas.length} notas selecionadas`);
                            }
                        },

                        /**
                         * Verifica se todas as notas vis√≠veis est√£o selecionadas
                         * @returns {boolean} true se todas as notas processadas est√£o selecionadas
                         */
                        todasNotasSelecionadas() {
                            if (this.notasProcessadas.length === 0) return false;
                            return this.notasProcessadas.every(nota => this.notasSelecionadas.includes(nota.id));
                        },

                        /**
                         * Exporta m√∫ltiplas notas selecionadas para um √∫nico PDF (relat√≥rio)
                         * Faz POST para /api/notas/pdf/relatorio com array de IDs
                         */
                        async exportarSelecionadas() {
                            if (this.notasSelecionadas.length === 0) {
                                mostrarToast('warning', 'Nenhuma Sele√ß√£o', 'Selecione pelo menos uma nota para exportar');
                                return;
                            }

                            try {
                                console.log(`üìä Exportando ${this.notasSelecionadas.length} nota(s) selecionada(s)`);

                                // Fazer requisi√ß√£o POST com array de IDs
                                const response = await fetch('/api/notas/pdf/relatorio', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        ids: this.notasSelecionadas
                                    })
                                });

                                if (!response.ok) {
                                    throw new Error(`Erro ao gerar PDF: ${response.statusText}`);
                                }

                                // Converter resposta em blob
                                const blob = await response.blob();

                                // Gerar timestamp no formato brasileiro (DDMMYYYY_HHmmss)
                                const agora = new Date();
                                const dia = String(agora.getDate()).padStart(2, '0');
                                const mes = String(agora.getMonth() + 1).padStart(2, '0');
                                const ano = agora.getFullYear();
                                const hora = String(agora.getHours()).padStart(2, '0');
                                const min = String(agora.getMinutes()).padStart(2, '0');
                                const seg = String(agora.getSeconds()).padStart(2, '0');
                                const timestamp = `${dia}${mes}${ano}_${hora}${min}${seg}`;

                                const nomeCompleto = `Relatorio_Notas_${timestamp}.pdf`;

                                // Criar link tempor√°rio para download
                                const url = window.URL.createObjectURL(blob);
                                const link = document.createElement('a');
                                link.href = url;
                                link.download = nomeCompleto;
                                document.body.appendChild(link);
                                link.click();

                                // Limpar
                                document.body.removeChild(link);
                                window.URL.revokeObjectURL(url);

                                console.log(`‚úì Relat√≥rio PDF gerado com sucesso: ${nomeCompleto}`);

                                // Limpar sele√ß√£o ap√≥s exporta√ß√£o bem-sucedida
                                const quantidadeExportada = this.notasSelecionadas.length;
                                this.notasSelecionadas = [];
                                console.log('‚úì Sele√ß√£o limpa ap√≥s exporta√ß√£o');

                                // Feedback visual com toast
                                mostrarToast('success', 'Relat√≥rio Gerado', `${quantidadeExportada} nota(s) exportada(s) com sucesso!`);

                            } catch (error) {
                                console.error('‚ùå Erro ao exportar notas selecionadas:', error);
                                mostrarToast('error', 'Erro ao Exportar Relat√≥rio', `N√£o foi poss√≠vel gerar o PDF: ${error.message}`);
                            }
                        },

                        abrirModalEtiquetas() {
                            this.modalEtiquetas = true;
                        },

                        async salvarEtiqueta() {
                            try {
                                // Se estiver editando, fazer PUT; sen√£o, fazer POST
                                const url = this.etiquetaEditandoId
                                    ? `/api/etiquetas/${this.etiquetaEditandoId}`
                                    : '/api/etiquetas';
                                const method = this.etiquetaEditandoId ? 'PUT' : 'POST';
                                const acao = this.etiquetaEditandoId ? 'atualizada' : 'criada';

                                const res = await fetch(url, {
                                    method: method,
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ nome: this.novaEtiqueta })
                                });
                                const data = await res.json();
                                if (data.success) {
                                    mostrarToast('success', 'Etiqueta Salva', `Etiqueta ${acao} com sucesso!`);
                                    this.novaEtiqueta = '';
                                    this.etiquetaEditandoId = null;
                                    await this.carregarEtiquetas();
                                    await this.carregarNotas(); // Recarregar notas para atualizar badges
                                } else {
                                    mostrarToast('error', 'Erro ao Salvar', data.message || 'N√£o foi poss√≠vel salvar a etiqueta');
                                }
                            } catch (err) {
                                mostrarToast('error', 'Erro ao Salvar', 'Ocorreu um erro ao salvar a etiqueta');
                                console.error('Erro ao salvar etiqueta:', err);
                            }
                        },

                        async deletarEtiqueta(id) {
                            if (!confirm('Deletar esta etiqueta? Todas as notas associadas tamb√©m ser√£o deletadas!')) return;
                            try {
                                const res = await fetch(`/api/etiquetas/${id}`, { method: 'DELETE' });
                                const data = await res.json();
                                if (data.success) {
                                    mostrarToast('success', 'Etiqueta Deletada', data.message || 'Etiqueta removida com sucesso!');
                                    await this.carregarEtiquetas();
                                    await this.carregarNotas();
                                } else {
                                    mostrarToast('error', 'Erro ao Deletar', data.message || 'N√£o foi poss√≠vel deletar a etiqueta');
                                }
                            } catch (err) {
                                mostrarToast('error', 'Erro ao Deletar', 'Ocorreu um erro ao deletar a etiqueta');
                                console.error('Erro ao deletar etiqueta:', err);
                            }
                        },

                        fecharModalEtiquetas() {
                            this.modalEtiquetas = false;
                            this.cancelarEdicaoEtiqueta();
                        },

                        iniciarEdicaoEtiqueta(etiqueta) {
                            this.etiquetaEditandoId = etiqueta.id;
                            this.novaEtiqueta = etiqueta.nome;
                        },

                        cancelarEdicaoEtiqueta() {
                            this.etiquetaEditandoId = null;
                            this.novaEtiqueta = '';
                        },

                        abrirModalStatus() {
                            this.modalStatus = true;
                        },

                        async salvarStatus() {
                            try {
                                // Se estiver editando, fazer PUT; sen√£o, fazer POST
                                const url = this.statusEditandoId
                                    ? `/api/status/${this.statusEditandoId}`
                                    : '/api/status';
                                const method = this.statusEditandoId ? 'PUT' : 'POST';
                                const acao = this.statusEditandoId ? 'atualizado' : 'criado';

                                console.log('Salvando status:', { nome: this.novoStatus.nome, corHex: this.novoStatus.cor, method });
                                const res = await fetch(url, {
                                    method: method,
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ nome: this.novoStatus.nome, corHex: this.novoStatus.cor })
                                });
                                const data = await res.json();
                                console.log('Resposta do servidor:', data);
                                if (data.success) {
                                    mostrarToast('success', 'Status Salvo', `Status ${acao} com sucesso!`);
                                    this.novoStatus = { nome: '', cor: '#6B7280' };
                                    this.statusEditandoId = null;
                                    await this.carregarStatus();
                                    await this.carregarNotas(); // Recarregar notas para atualizar badges
                                } else {
                                    mostrarToast('error', 'Erro ao Salvar', data.message || 'N√£o foi poss√≠vel salvar o status');
                                }
                            } catch (err) {
                                console.error('Erro ao salvar:', err);
                                mostrarToast('error', 'Erro ao Salvar', 'Ocorreu um erro ao salvar o status');
                            }
                        },

                        async deletarStatus(id) {
                            if (!confirm('Deseja realmente deletar este status?')) return;
                            try {
                                const res = await fetch(`/api/status/${id}`, { method: 'DELETE' });
                                const data = await res.json();
                                if (data.success) {
                                    mostrarToast('success', 'Status Deletado', data.message || 'Status removido com sucesso!');
                                    await this.carregarStatus();
                                } else {
                                    mostrarToast('error', 'Erro ao Deletar', data.message || 'N√£o foi poss√≠vel deletar o status');
                                }
                            } catch (err) {
                                mostrarToast('error', 'Erro ao Deletar', 'Ocorreu um erro ao deletar o status');
                                console.error('Erro ao deletar status:', err);
                            }
                        },

                        fecharModalStatus() {
                            this.modalStatus = false;
                            this.cancelarEdicaoStatus();
                        },

                        /**
                         * Abre modal de preview para visualizar nota
                         * @param {number} notaId - ID da nota a ser visualizada
                         */
                        async visualizarNota(notaId) {
                            try {
                                console.log(`üëÅÔ∏è Abrindo preview da nota ID: ${notaId}`);

                                // Buscar dados da nota via API
                                const res = await fetch(`/api/notas/${notaId}`);
                                const data = await res.json();

                                if (!data.success) {
                                    mostrarToast('error', 'Erro ao Carregar', 'N√£o foi poss√≠vel carregar a nota');
                                    return;
                                }

                                // Armazenar nota e abrir modal
                                this.notaPreview = data.dados;
                                this.modalPreview = true;

                                console.log('‚úì Nota carregada para preview:', this.notaPreview);

                            } catch (err) {
                                console.error('Erro ao visualizar nota:', err);
                                mostrarToast('error', 'Erro ao Visualizar', 'Ocorreu um erro ao carregar a nota');
                            }
                        },

                        /**
                         * Fecha modal de preview
                         */
                        fecharModalPreview() {
                            this.modalPreview = false;
                            // Limpar dados ap√≥s anima√ß√£o de fechamento
                            setTimeout(() => {
                                this.notaPreview = null;
                            }, 300);
                        },

                        /**
                         * Exporta PDF da nota que est√° em preview
                         */
                        async exportarPDFPreview() {
                            if (!this.notaPreview) return;
                            await this.gerarPDF(this.notaPreview.id, this.notaPreview.titulo);
                        },

                        /**
                         * Verifica se h√° alertas cr√≠ticos (atrasados ou vencendo hoje)
                         * @returns {boolean} true se houver alertas cr√≠ticos
                         */
                        temAlertasCriticos() {
                            return this.alertasUrgentes.some(alerta => alerta.diasRestantes <= 0);
                        },

                        abrirModalAlertas() {
                            this.modalAlertas = true;
                        },

                        fecharModalAlertas() {
                            this.modalAlertas = false;
                        },

                        iniciarEdicaoStatus(status) {
                            this.statusEditandoId = status.id;
                            this.novoStatus.nome = status.nome;
                            this.novoStatus.cor = status.corHex;
                        },

                        cancelarEdicaoStatus() {
                            this.statusEditandoId = null;
                            this.novoStatus = { nome: '', cor: '#6B7280' };
                        },

                        getBadgeClass(dias) {
                            if (dias < 0) return 'badge-critico';
                            if (dias <= 1) return 'badge-urgente';
                            if (dias <= 3) return 'badge-atencao';
                            if (dias <= 5) return 'badge-aviso';
                            return '';
                        },

                        getDiasPrazoText(nota) {
                            const dias = nota.diasRestantes;
                            if (dias < 0) return `Atrasada ${Math.abs(dias)} dia(s)`;
                            if (dias === 0) return 'Vence HOJE';
                            if (dias === 1) return 'Vence AMANH√É';
                            return `${dias} dias restantes`;
                        },

                        /**
                         * Calcula a cor do texto (branco ou preto) baseado na lumin√¢ncia da cor de fundo
                         * para garantir contraste adequado.
                         *
                         * @param {string} hexColor - Cor em formato hexadecimal (#RRGGBB)
                         * @returns {string} 'white' ou 'black'
                         */
                        getContrastColor(hexColor) {
                            if (!hexColor) return 'white';

                            // Remove o # se existir
                            const hex = hexColor.replace('#', '');

                            // Converte para RGB
                            const r = parseInt(hex.substr(0, 2), 16);
                            const g = parseInt(hex.substr(2, 2), 16);
                            const b = parseInt(hex.substr(4, 2), 16);

                            // Calcula a lumin√¢ncia relativa usando a f√≥rmula WCAG
                            // https://www.w3.org/TR/WCAG20/#relativeluminancedef
                            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

                            // Se a lumin√¢ncia for maior que 0.5, usar texto escuro; sen√£o, usar texto claro
                            return luminance > 0.5 ? 'black' : 'white';
                        }
                    }
                }
            </script>
        </div>
    </th:block>
</body>
</html>

<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Anota√ß√µes - Notisblokk</title>
    <link rel="stylesheet" href="/css/notas.css">
</head>
<body>
    <th:block th:replace="~{layout/base :: base(~{::main-content})}">
        <div th:fragment="main-content" x-data="notasApp()">
            <!-- Container de Toast Notifications -->
            <div id="toast-container" class="toast-container"></div>

            <!-- Loading Overlay -->
            <div id="loading-overlay" class="loading-overlay">
                <div class="loading-spinner">
                    <div class="spinner"></div>
                    <div class="loading-text" id="loading-text">Carregando...</div>
                </div>
            </div>

            <!-- Cabe√ßalho e A√ß√µes -->
            <div class="header-compact">
                <h1 class="page-title">üìù Anota√ß√µes</h1>
                <div class="acoes-topo">
                    <a href="/notas/nova" class="btn btn-primary btn-sm">
                        ‚ûï Nova Nota
                    </a>
                    <!-- Contador e bot√£o de exporta√ß√£o em massa -->
                    <div x-show="notasSelecionadas.length > 0" class="badge badge-info" style="padding: 0.5rem 1rem; font-size: 0.9rem;">
                        ‚úì <span x-text="notasSelecionadas.length"></span> selecionada(s)
                    </div>
                    <button
                        x-show="notasSelecionadas.length > 0"
                        @click="exportarSelecionadas()"
                        class="btn btn-success btn-sm"
                        title="Exportar notas selecionadas para PDF">
                        üìä Exportar Selecionadas (<span x-text="notasSelecionadas.length"></span>)
                    </button>
                    <button
                        x-show="notasSelecionadas.length > 0"
                        @click="abrirModalMudarStatus()"
                        class="btn btn-primary btn-sm"
                        title="Mudar status das notas selecionadas">
                        üìä Mudar Status (<span x-text="notasSelecionadas.length"></span>)
                    </button>
                    <button
                        x-show="notasSelecionadas.length > 0"
                        @click="abrirModalDeletarSelecionadas()"
                        class="btn btn-danger btn-sm"
                        title="Deletar notas selecionadas">
                        üóëÔ∏è Deletar Selecionadas (<span x-text="notasSelecionadas.length"></span>)
                    </button>
                    <button @click="abrirModalAlertas()" class="btn btn-sm btn-alertas" :class="{'btn-danger': alertasUrgentes.length > 0, 'btn-warning': alertasUrgentes.length === 0, 'pulse-animation': temAlertasCriticos()}">
                        üîî Alertas
                        <span x-show="alertasUrgentes.length > 0" class="badge-counter" x-text="alertasUrgentes.length"></span>
                    </button>
                    <button @click="abrirModalEtiquetas()" class="btn btn-secondary btn-sm">
                        üè∑Ô∏è Etiquetas
                    </button>
                    <button @click="abrirModalStatus()" class="btn btn-secondary btn-sm">
                        üìä Status
                    </button>
                </div>
            </div>

            <!-- Barra de Pesquisa -->
            <div class="card mb-2">
                <div class="card-body-compact">
                    <div class="filtros-pesquisa-row">
                        <input
                            type="text"
                            x-model="termoPesquisa"
                            @input="pesquisarNotas()"
                            placeholder="üîç Pesquisar notas..."
                            class="form-control-compact search-full-width"
                        >
                    </div>
                </div>
            </div>

            <!-- Filtros Visuais com Badges (Colaps√°vel) -->
            <div class="card mb-2" x-show="etiquetas.length > 0 || statusList.length > 0">
                <div class="card-body-compact-collapsible">
                    <div class="collapsible-header" @click="secaoFiltrosVisiveisExpandida = !secaoFiltrosVisiveisExpandida">
                        <span class="collapsible-title">
                            üè∑Ô∏è Filtros por Etiquetas e Status
                            <span x-show="(filtrosAtivos.etiquetas.length + filtrosAtivos.status.length) > 0"
                                  class="filter-active-count"
                                  x-text="'(' + (filtrosAtivos.etiquetas.length + filtrosAtivos.status.length) + ' ativo' + ((filtrosAtivos.etiquetas.length + filtrosAtivos.status.length) > 1 ? 's' : '') + ')'">
                            </span>
                        </span>
                        <span class="collapsible-icon" x-text="secaoFiltrosVisiveisExpandida ? '‚ñ≤' : '‚ñº'"></span>
                    </div>

                    <div x-show="secaoFiltrosVisiveisExpandida" class="collapsible-content">
                        <!-- Etiquetas -->
                        <div x-show="etiquetas.length > 0" class="filter-section-compact">
                            <div class="filter-section-header-compact">
                                <span class="filter-label-compact">üè∑Ô∏è Etiquetas:</span>
                                <button
                                    x-show="filtrosAtivos.etiquetas.length > 0"
                                    @click.stop="limparFiltrosEtiquetas()"
                                    class="btn-clear-filter"
                                    title="Limpar filtros de etiquetas">
                                    ‚úï Limpar
                                </button>
                            </div>
                            <div class="filter-badges-compact">
                                <template x-for="etiqueta in etiquetas" :key="etiqueta.id">
                                    <button
                                        @click="toggleFiltroEtiqueta(etiqueta.id)"
                                        class="filter-badge-compact"
                                        :class="{ 'filter-badge-active': filtroEtiquetaAtivo(etiqueta.id) }"
                                        :title="'Filtrar por ' + etiqueta.nome">
                                        <span class="filter-badge-name" x-text="etiqueta.nome"></span>
                                        <span class="filter-badge-count" x-text="contarNotasPorEtiqueta(etiqueta.id)"></span>
                                    </button>
                                </template>
                            </div>
                        </div>

                        <!-- Status -->
                        <div x-show="statusList.length > 0" class="filter-section-compact">
                            <div class="filter-section-header-compact">
                                <span class="filter-label-compact">üìä Status:</span>
                                <button
                                    x-show="filtrosAtivos.status.length > 0"
                                    @click.stop="limparFiltrosStatus()"
                                    class="btn-clear-filter"
                                    title="Limpar filtros de status">
                                    ‚úï Limpar
                                </button>
                            </div>
                            <div class="filter-badges-compact">
                                <template x-for="status in statusList" :key="status.id">
                                    <button
                                        @click="toggleFiltroStatus(status.id)"
                                        class="filter-badge-compact"
                                        :class="{ 'filter-badge-active': filtroStatusAtivo(status.id) }"
                                        :style="filtroStatusAtivo(status.id) ? 'background-color: ' + status.corHex + '; border-color: ' + status.corHex + '; color: ' + getContrastColor(status.corHex) : ''"
                                        :title="'Filtrar por ' + status.nome">
                                        <span class="filter-badge-name" x-text="status.nome"></span>
                                        <span class="filter-badge-count" x-text="contarNotasPorStatus(status.id)"></span>
                                    </button>
                                </template>
                            </div>
                        </div>

                        <!-- Bot√£o Limpar Todos os Filtros -->
                        <div x-show="filtrosAtivos.etiquetas.length > 0 || filtrosAtivos.status.length > 0" class="filter-section-compact" style="margin-top: 0.5rem;">
                            <button
                                @click="limparTodosFiltros()"
                                class="btn btn-secondary btn-sm btn-clear-all">
                                ‚úï Limpar Todos os Filtros
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Filtro por Intervalo de Datas (Colaps√°vel) -->
            <div class="card mb-2">
                <div class="card-body-compact-collapsible">
                    <div class="collapsible-header" @click="secaoFiltroDataExpandida = !secaoFiltroDataExpandida">
                        <span class="collapsible-title">
                            üìÖ Filtrar por Prazo
                            <span x-show="filtroData.inicio || filtroData.fim"
                                  class="filter-active-count">
                                (ativo)
                            </span>
                        </span>
                        <span class="collapsible-icon" x-text="secaoFiltroDataExpandida ? '‚ñ≤' : '‚ñº'"></span>
                    </div>

                    <div x-show="secaoFiltroDataExpandida" class="collapsible-content">
                        <div class="date-filter-container-compact">
                            <!-- Campos de Data -->
                            <div class="date-filter-inputs-compact">
                                <div class="date-input-group-compact">
                                    <label for="dataInicio">De:</label>
                                    <input
                                        type="date"
                                        id="dataInicio"
                                        x-model="filtroData.inicio"
                                        @change="aplicarFiltroData()"
                                        :max="filtroData.fim || ''"
                                        class="form-control-compact">
                                </div>

                                <div class="date-input-group-compact">
                                    <label for="dataFim">At√©:</label>
                                    <input
                                        type="date"
                                        id="dataFim"
                                        x-model="filtroData.fim"
                                        @change="aplicarFiltroData()"
                                        :min="filtroData.inicio || ''"
                                        class="form-control-compact">
                                </div>

                                <button
                                    x-show="filtroData.inicio || filtroData.fim"
                                    @click="limparFiltroData()"
                                    class="btn btn-secondary btn-sm"
                                    title="Limpar filtro de data">
                                    ‚úï Limpar
                                </button>
                            </div>

                            <!-- Presets de Data -->
                            <div class="date-filter-presets-compact">
                                <button
                                    @click="aplicarPreset('hoje')"
                                    class="btn btn-sm btn-preset"
                                    :class="{ 'btn-preset-active': presetAtivo === 'hoje' }">
                                    Hoje
                                </button>
                                <button
                                    @click="aplicarPreset('esta-semana')"
                                    class="btn btn-sm btn-preset"
                                    :class="{ 'btn-preset-active': presetAtivo === 'esta-semana' }">
                                    Esta Semana
                                </button>
                                <button
                                    @click="aplicarPreset('este-mes')"
                                    class="btn btn-sm btn-preset"
                                    :class="{ 'btn-preset-active': presetAtivo === 'este-mes' }">
                                    Este M√™s
                                </button>
                                <button
                                    @click="aplicarPreset('proximos-7-dias')"
                                    class="btn btn-sm btn-preset"
                                    :class="{ 'btn-preset-active': presetAtivo === 'proximos-7-dias' }">
                                    Pr√≥ximos 7 Dias
                                </button>
                                <button
                                    @click="aplicarPreset('proximos-30-dias')"
                                    class="btn btn-sm btn-preset"
                                    :class="{ 'btn-preset-active': presetAtivo === 'proximos-30-dias' }">
                                    Pr√≥ximos 30 Dias
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tabela de Notas -->
            <div class="card">
                <!-- Cabe√ßalho da Tabela com Controle de Colunas -->
                <div class="table-header-controls">
                    <button @click="mostrarControlesColunas = !mostrarControlesColunas" class="btn btn-secondary btn-sm btn-icon-controls" title="Configurar colunas vis√≠veis">
                        ‚öôÔ∏è Configurar Colunas
                    </button>
                </div>

                <!-- Controles de Colunas -->
                <div x-show="mostrarControlesColunas" class="column-controls-table">
                    <label class="column-toggle-compact">
                        <input type="checkbox" x-model="colunasVisiveis.titulo"> T√≠tulo
                    </label>
                    <label class="column-toggle-compact">
                        <input type="checkbox" x-model="colunasVisiveis.etiqueta"> Etiqueta
                    </label>
                    <label class="column-toggle-compact">
                        <input type="checkbox" x-model="colunasVisiveis.status"> Status
                    </label>
                    <label class="column-toggle-compact">
                        <input type="checkbox" x-model="colunasVisiveis.prazo"> Prazo
                    </label>
                    <label class="column-toggle-compact">
                        <input type="checkbox" x-model="colunasVisiveis.diasRestantes"> Dias Restantes
                    </label>
                </div>

                <div class="table-responsive">
                    <table class="notas-table">
                        <thead>
                            <tr>
                                <!-- Coluna de sele√ß√£o m√∫ltipla -->
                                <th style="width: 40px; text-align: center;">
                                    <input
                                        type="checkbox"
                                        @change="toggleSelecionarTodas()"
                                        :checked="todasNotasSelecionadas()"
                                        title="Selecionar/Desselecionar todas"
                                    >
                                </th>
                                <th x-show="colunasVisiveis.titulo" @click="ordenarPor('titulo')" class="sortable">
                                    T√≠tulo <span x-text="getSortIcon('titulo')"></span>
                                </th>
                                <th x-show="colunasVisiveis.etiqueta" @click="ordenarPor('etiqueta')" class="sortable">
                                    Etiqueta <span x-text="getSortIcon('etiqueta')"></span>
                                </th>
                                <th x-show="colunasVisiveis.status" @click="ordenarPor('status')" class="sortable">
                                    Status <span x-text="getSortIcon('status')"></span>
                                </th>
                                <th x-show="colunasVisiveis.prazo" @click="ordenarPor('prazo')" class="sortable">
                                    Prazo <span x-text="getSortIcon('prazo')"></span>
                                </th>
                                <th x-show="colunasVisiveis.diasRestantes" @click="ordenarPor('diasRestantes')" class="sortable">
                                    Dias Restantes <span x-text="getSortIcon('diasRestantes')"></span>
                                </th>
                                <th class="acoes-col">A√ß√µes</th>
                            </tr>
                        </thead>
                        <tbody>
                            <template x-for="nota in notasProcessadas" :key="nota.id">
                                <tr :class="{'nota-atrasada': nota.diasRestantes !== null && nota.diasRestantes < 0, 'nota-urgente': nota.diasRestantes !== null && nota.diasRestantes >= 0 && nota.diasRestantes <= 3}">
                                    <!-- Checkbox de sele√ß√£o -->
                                    <td style="width: 40px; text-align: center;">
                                        <input
                                            type="checkbox"
                                            :value="nota.id"
                                            @change="toggleSelecaoNota(nota.id)"
                                            :checked="notaEstaSelecionada(nota.id)"
                                        >
                                    </td>
                                    <td x-show="colunasVisiveis.titulo">
                                        <strong @click="visualizarNota(nota.id)" style="cursor: pointer; color: var(--color-primary); text-decoration: underline;" x-text="nota.titulo"></strong>
                                    </td>
                                    <td x-show="colunasVisiveis.etiqueta">
                                        <span class="badge" :style="'background-color: ' + (nota.etiqueta.corHex || '#6B7280') + '; color: ' + getContrastColor(nota.etiqueta.corHex || '#6B7280')" x-text="nota.etiqueta.nome"></span>
                                    </td>
                                    <td x-show="colunasVisiveis.status">
                                        <span class="badge" :style="'background-color: ' + nota.status.corHex + '; color: ' + getContrastColor(nota.status.corHex)" x-text="nota.status.nome"></span>
                                    </td>
                                    <td x-show="colunasVisiveis.prazo" x-text="nota.prazoFinal"></td>
                                    <td x-show="colunasVisiveis.diasRestantes">
                                        <span class="badge" :class="getBadgeClass(nota.diasRestantes)" x-text="getDiasPrazoText(nota)"></span>
                                    </td>
                                    <td class="acoes-col">
                                        <div class="btn-group">
                                            <a :href="'/notas/editar/' + nota.id" class="btn btn-sm btn-primary" title="Editar">‚úèÔ∏è</a>
                                            <!-- Bot√£o para exportar nota individual em PDF -->
                                            <button @click="gerarPDF(nota.id, nota.titulo)" class="btn btn-sm btn-success" title="Exportar PDF">üìÑ</button>
                                            <button @click="deletarNota(nota.id)" class="btn btn-sm btn-danger" title="Deletar">üóëÔ∏è</button>
                                        </div>
                                    </td>
                                </tr>
                            </template>
                        </tbody>
                    </table>

                    <div x-show="notasProcessadas.length === 0" class="empty-state">
                        <div class="empty-state-icon">üìù</div>
                        <p>Nenhuma nota encontrada</p>
                    </div>
                </div>
            </div>

            <!-- Modal Etiquetas -->
            <div class="modal-overlay" :class="{ active: modalEtiquetas }">
                <div class="modal modal-large">
                    <div class="modal-header">
                        <h2 class="modal-title">Gerenciar Etiquetas</h2>
                        <button @click="fecharModalEtiquetas()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form @submit.prevent="salvarEtiqueta()" class="mb-3">
                            <div class="d-flex gap-2">
                                <input type="text" x-model="novaEtiqueta" placeholder="Nome da etiqueta" class="form-input" required>
                                <button type="submit" class="btn btn-primary" x-text="etiquetaEditandoId ? 'Salvar' : 'Adicionar'"></button>
                                <button type="button" x-show="etiquetaEditandoId" @click="cancelarEdicaoEtiqueta()" class="btn btn-secondary">Cancelar</button>
                            </div>
                        </form>
                        <div class="item-list">
                            <template x-for="etiqueta in etiquetas" :key="etiqueta.id">
                                <div class="item-list-row">
                                    <span x-text="etiqueta.nome + ' (' + etiqueta.totalNotas + ' notas)'"></span>
                                    <div class="btn-group">
                                        <button @click="iniciarEdicaoEtiqueta(etiqueta)" class="btn btn-sm btn-secondary" title="Editar">‚úèÔ∏è</button>
                                        <button @click="deletarEtiqueta(etiqueta.id)" class="btn btn-sm btn-danger" title="Deletar">üóëÔ∏è</button>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="fecharModalEtiquetas()" class="btn btn-secondary">Fechar</button>
                    </div>
                </div>
            </div>

            <!-- Modal Status -->
            <div class="modal-overlay" :class="{ active: modalStatus }">
                <div class="modal modal-large">
                    <div class="modal-header">
                        <h2 class="modal-title">Gerenciar Status</h2>
                        <button @click="fecharModalStatus()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <form @submit.prevent="salvarStatus()" class="mb-3">
                            <div class="d-flex gap-2" style="align-items: center;">
                                <input type="text" x-model="novoStatus.nome" placeholder="Nome do status" class="form-input" required>
                                <input type="color" x-model="novoStatus.cor" class="form-control" style="width: 80px; height: 40px; padding: 2px;" required>
                                <div class="color-indicator" :style="'background-color: ' + novoStatus.cor" style="width: 40px; height: 40px;"></div>
                                <button type="submit" class="btn btn-primary" x-text="statusEditandoId ? 'Salvar' : 'Adicionar'"></button>
                                <button type="button" x-show="statusEditandoId" @click="cancelarEdicaoStatus()" class="btn btn-secondary">Cancelar</button>
                            </div>
                        </form>
                        <div class="item-list">
                            <template x-for="status in statusList" :key="status.id">
                                <div class="item-list-row">
                                    <div class="d-flex gap-2 align-items-center">
                                        <div class="color-indicator" :style="'background-color: ' + status.corHex"></div>
                                        <span x-text="status.nome"></span>
                                    </div>
                                    <div class="btn-group">
                                        <button @click="iniciarEdicaoStatus(status)" class="btn btn-sm btn-secondary" title="Editar">‚úèÔ∏è</button>
                                        <button @click="deletarStatus(status.id)" class="btn btn-sm btn-danger" title="Deletar">üóëÔ∏è</button>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="fecharModalStatus()" class="btn btn-secondary">Fechar</button>
                    </div>
                </div>
            </div>

            <!-- Modal Preview de Nota -->
            <div class="modal-overlay" :class="{ active: modalPreview }">
                <div class="modal modal-large">
                    <div class="modal-header">
                        <h2 class="modal-title">üëÅÔ∏è Visualizar Nota</h2>
                        <button @click="fecharModalPreview()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body" x-show="notaPreview">
                        <!-- T√≠tulo da Nota -->
                        <h3 class="nota-preview-titulo" x-text="notaPreview?.titulo"></h3>

                        <!-- Metadados -->
                        <div class="nota-preview-meta">
                            <div class="meta-item">
                                <strong>Etiqueta:</strong>
                                <span class="badge" :style="'background-color: ' + (notaPreview?.etiqueta?.corHex || '#6B7280') + '; color: ' + getContrastColor(notaPreview?.etiqueta?.corHex || '#6B7280')" x-text="notaPreview?.etiqueta?.nome"></span>
                            </div>
                            <div class="meta-item">
                                <strong>Status:</strong>
                                <span class="badge" :style="'background-color: ' + (notaPreview?.status?.corHex || '#6B7280') + '; color: ' + getContrastColor(notaPreview?.status?.corHex || '#6B7280')" x-text="notaPreview?.status?.nome"></span>
                            </div>
                            <div class="meta-item">
                                <strong>Prazo Final:</strong>
                                <span x-text="notaPreview?.prazoFinal"></span>
                            </div>
                        </div>

                        <!-- Conte√∫do da Nota -->
                        <div class="nota-preview-conteudo">
                            <h4>Conte√∫do:</h4>
                            <div class="ql-editor" x-html="notaPreview?.conteudo || '<p>Sem conte√∫do</p>'"></div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="exportarPDFPreview()" class="btn btn-success">
                            üìÑ Exportar PDF
                        </button>
                        <a :href="'/notas/editar/' + notaPreview?.id" class="btn btn-primary">
                            ‚úèÔ∏è Editar
                        </a>
                        <button @click="fecharModalPreview()" class="btn btn-secondary">Fechar</button>
                    </div>
                </div>
            </div>

            <!-- Modal Confirmar Exclus√£o -->
            <div class="modal-overlay" :class="{ active: modalConfirmarDeletar }">
                <div class="modal modal-confirm-delete">
                    <div class="modal-header modal-header-danger">
                        <h2 class="modal-title">‚ö†Ô∏è Confirmar Exclus√£o</h2>
                        <button @click="cancelarDeletar()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>Tem certeza que deseja deletar a seguinte nota?</p>
                        <div class="nota-deletar-info" x-show="notaDeletar">
                            <strong x-text="notaDeletar?.titulo"></strong>
                        </div>
                        <p class="text-danger">‚ö†Ô∏è Esta a√ß√£o n√£o pode ser desfeita!</p>
                    </div>
                    <div class="modal-footer modal-footer-danger">
                        <button @click="cancelarDeletar()" class="btn btn-secondary">
                            ‚úï Cancelar
                        </button>
                        <button @click="confirmarDeletar()" class="btn btn-danger">
                            üóëÔ∏è Deletar Permanentemente
                        </button>
                    </div>
                </div>
            </div>

            <!-- Modal Confirmar Deletar Selecionadas -->
            <div class="modal-overlay" :class="{ active: modalDeletarSelecionadas }">
                <div class="modal modal-confirm-delete">
                    <div class="modal-header modal-header-danger">
                        <h2 class="modal-title">‚ö†Ô∏è Deletar M√∫ltiplas Notas</h2>
                        <button @click="fecharModalDeletarSelecionadas()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>Tem certeza que deseja deletar <strong x-text="notasSelecionadas.length"></strong> nota(s) selecionada(s)?</p>
                        <p class="text-danger" style="font-weight: 600; margin-top: 1rem;">
                            ‚ö†Ô∏è Esta a√ß√£o n√£o pode ser desfeita!
                        </p>
                        <div class="nota-deletar-info" style="max-height: 200px; overflow-y: auto; margin-top: 1rem; padding: 0.5rem; background-color: var(--color-bg-secondary); border-radius: 8px;">
                            <p style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--color-text-secondary);">
                                Notas que ser√£o deletadas:
                            </p>
                            <template x-for="(notaId, index) in notasSelecionadas" :key="notaId">
                                <div style="padding: 0.25rem 0; border-bottom: 1px solid var(--color-border);">
                                    <span x-text="(index + 1) + '. ' + obterTituloNota(notaId)"></span>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="modal-footer modal-footer-danger">
                        <button @click="fecharModalDeletarSelecionadas()" class="btn btn-secondary">
                            ‚úï Cancelar
                        </button>
                        <button @click="confirmarDeletarSelecionadas()" class="btn btn-danger">
                            üóëÔ∏è Deletar <span x-text="notasSelecionadas.length"></span> Nota(s)
                        </button>
                    </div>
                </div>
            </div>

            <!-- Modal Mudar Status das Selecionadas -->
            <div class="modal-overlay" :class="{ active: modalMudarStatus }">
                <div class="modal">
                    <div class="modal-header">
                        <h2 class="modal-title">üìä Mudar Status</h2>
                        <button @click="fecharModalMudarStatus()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body">
                        <p>Selecione o novo status para <strong x-text="notasSelecionadas.length"></strong> nota(s) selecionada(s):</p>

                        <div style="margin-top: 1.5rem;">
                            <label for="novoStatusMassa" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--color-text-primary);">
                                Novo Status:
                            </label>
                            <select
                                id="novoStatusMassa"
                                x-model="novoStatusMassa"
                                class="form-control"
                                style="width: 100%;">
                                <option value="">-- Selecione um status --</option>
                                <template x-for="status in statusList" :key="status.id">
                                    <option :value="status.id" x-text="status.nome"></option>
                                </template>
                            </select>
                        </div>

                        <!-- Pr√©via das notas que ser√£o alteradas -->
                        <div class="nota-deletar-info" style="max-height: 150px; overflow-y: auto; margin-top: 1.5rem; padding: 0.5rem; background-color: var(--color-bg-secondary); border-radius: 8px;">
                            <p style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--color-text-secondary);">
                                Notas que ser√£o atualizadas:
                            </p>
                            <template x-for="(notaId, index) in notasSelecionadas" :key="notaId">
                                <div style="padding: 0.25rem 0; border-bottom: 1px solid var(--color-border); font-size: 0.875rem;">
                                    <span x-text="(index + 1) + '. ' + obterTituloNota(notaId)"></span>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="fecharModalMudarStatus()" class="btn btn-secondary">
                            ‚úï Cancelar
                        </button>
                        <button
                            @click="confirmarMudarStatus()"
                            class="btn btn-primary"
                            :disabled="!novoStatusMassa">
                            üìä Atualizar <span x-text="notasSelecionadas.length"></span> Nota(s)
                        </button>
                    </div>
                </div>
            </div>

            <!-- Modal Alertas -->
            <div class="modal-overlay" :class="{ active: modalAlertas }">
                <div class="modal modal-large">
                    <div class="modal-header">
                        <h2 class="modal-title">üîî Alertas de Anota√ß√µes</h2>
                        <button @click="fecharModalAlertas()" class="modal-close">&times;</button>
                    </div>
                    <div class="modal-body" style="max-height: 600px; overflow-y: auto;">
                        <div x-show="alertasUrgentes.length === 0" class="empty-state">
                            <div class="empty-state-icon">‚úÖ</div>
                            <p>Nenhum alerta urgente no momento!</p>
                        </div>

                        <div x-show="alertasUrgentes.length > 0" style="display: flex; flex-direction: column; gap: 0.75rem;">
                            <template x-for="alerta in alertasUrgentes" :key="alerta.id">
                                <div class="alerta-card" :class="'alerta-' + alerta.nivel.toLowerCase()">
                                    <div class="alerta-card-header">
                                        <span class="alerta-icon-grande" x-text="getAlertaIcon(alerta.nivel)"></span>
                                        <span class="alerta-nivel-badge" x-text="alerta.nivel"></span>
                                    </div>
                                    <div class="alerta-card-body">
                                        <h3 class="alerta-titulo" x-text="alerta.titulo"></h3>
                                        <div class="alerta-prazo-info">
                                            <strong>Prazo:</strong> <span x-text="alerta.prazoTexto"></span>
                                        </div>
                                    </div>
                                    <div class="alerta-card-footer">
                                        <a :href="'/notas/editar/' + alerta.id" class="btn btn-sm btn-primary">
                                            Ver Anota√ß√£o ‚Üí
                                        </a>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button @click="fecharModalAlertas()" class="btn btn-secondary">Fechar</button>
                    </div>
                </div>
            </div>

            <script>
                /**
                 * ========================================
                 * INDICADOR DE LOADING
                 * ========================================
                 */

                /**
                 * Mostra o indicador de loading com mensagem opcional.
                 * @param {string} message - Mensagem a exibir (padr√£o: "Carregando...")
                 */
                function mostrarLoading(message = 'Carregando...') {
                    const overlay = document.getElementById('loading-overlay');
                    const text = document.getElementById('loading-text');

                    if (overlay && text) {
                        text.textContent = message;
                        overlay.classList.add('active');
                        console.log(`‚è≥ Loading: ${message}`);
                    }
                }

                /**
                 * Oculta o indicador de loading.
                 */
                function ocultarLoading() {
                    const overlay = document.getElementById('loading-overlay');

                    if (overlay) {
                        overlay.classList.remove('active');
                        console.log('‚úì Loading ocultado');
                    }
                }

                /**
                 * ========================================
                 * SISTEMA DE TOAST NOTIFICATIONS
                 * ========================================
                 */

                /**
                 * Sistema de Toast Notifications
                 * @param {string} tipo - Tipo do toast: 'success', 'error', 'warning', 'info'
                 * @param {string} titulo - T√≠tulo da notifica√ß√£o
                 * @param {string} mensagem - Mensagem detalhada (opcional)
                 * @param {number} duracao - Dura√ß√£o em ms (padr√£o: 4000ms)
                 */
                function mostrarToast(tipo, titulo, mensagem = '', duracao = 4000) {
                    const container = document.getElementById('toast-container');
                    if (!container) {
                        console.error('Container de toasts n√£o encontrado');
                        return;
                    }

                    // Mapear √≠cones por tipo
                    const icones = {
                        success: '‚úì',
                        error: '‚úï',
                        warning: '‚ö†',
                        info: '‚Ñπ'
                    };

                    // Criar elemento do toast
                    const toast = document.createElement('div');
                    toast.className = `toast toast-${tipo}`;
                    toast.innerHTML = `
                        <div class="toast-icon">${icones[tipo] || '‚Ñπ'}</div>
                        <div class="toast-content">
                            <div class="toast-title">${titulo}</div>
                            ${mensagem ? `<div class="toast-message">${mensagem}</div>` : ''}
                        </div>
                        <button class="toast-close" aria-label="Fechar">&times;</button>
                    `;

                    // Adicionar ao container
                    container.appendChild(toast);

                    // Bot√£o de fechar
                    const closeBtn = toast.querySelector('.toast-close');
                    closeBtn.addEventListener('click', () => {
                        removerToast(toast);
                    });

                    // Auto-remover ap√≥s dura√ß√£o
                    setTimeout(() => {
                        removerToast(toast);
                    }, duracao);

                    // Log para debugging
                    console.log(`üîî Toast [${tipo}]: ${titulo}${mensagem ? ' - ' + mensagem : ''}`);
                }

                /**
                 * Remove um toast com anima√ß√£o
                 * @param {HTMLElement} toast - Elemento do toast a ser removido
                 */
                function removerToast(toast) {
                    toast.classList.add('toast-hiding');
                    setTimeout(() => {
                        toast.remove();
                    }, 300);
                }

                function notasApp() {
                    return {
                        notas: [],
                        notasFiltradas: [],
                        notasProcessadas: [],
                        alertasUrgentes: [],
                        etiquetas: [],
                        statusList: [],
                        modalEtiquetas: false,
                        modalStatus: false,
                        modalAlertas: false,
                        modalPreview: false,
                        notaPreview: null,
                        modalConfirmarDeletar: false,
                        notaDeletar: null,
                        modalDeletarSelecionadas: false,
                        modalMudarStatus: false,
                        novoStatusMassa: '',
                        novaEtiqueta: '',
                        novoStatus: { nome: '', cor: '#6B7280' },
                        etiquetaEditandoId: null,
                        statusEditandoId: null,
                        filtroEtiqueta: '',
                        filtroStatus: '',
                        termoPesquisa: '',
                        mostrarControlesColunas: false,
                        colunaOrdenacao: 'diasRestantes',
                        direcaoOrdenacao: 'asc',
                        colunasVisiveis: {
                            titulo: true,
                            etiqueta: true,
                            status: true,
                            prazo: true,
                            diasRestantes: true
                        },
                        pesquisaTimeout: null,
                        // Sele√ß√£o m√∫ltipla de notas para exporta√ß√£o em massa
                        notasSelecionadas: [],
                        // Filtros ativos (permite m√∫ltiplas sele√ß√µes)
                        filtrosAtivos: {
                            etiquetas: [],
                            status: []
                        },
                        // Filtro por intervalo de datas
                        filtroData: {
                            inicio: '',
                            fim: ''
                        },
                        presetAtivo: '',
                        // Controle de se√ß√µes colaps√°veis
                        secaoFiltrosVisiveisExpandida: false,
                        secaoFiltroDataExpandida: false,

                        async init() {
                            // Carregar prefer√™ncias de colunas do localStorage
                            const colunasSalvas = localStorage.getItem('notasColunasVisiveis');
                            if (colunasSalvas) {
                                this.colunasVisiveis = JSON.parse(colunasSalvas);
                            }

                            await this.carregarEtiquetas();
                            await this.carregarStatus();
                            await this.carregarNotas();
                            // Alertas s√£o gerados automaticamente em processarNotas()

                            // Watch para salvar prefer√™ncias de colunas
                            this.$watch('colunasVisiveis', (value) => {
                                localStorage.setItem('notasColunasVisiveis', JSON.stringify(value));
                            });

                            // Configurar atalhos de teclado
                            this.setupKeyboardShortcuts();
                        },

                        async carregarNotas() {
                            mostrarLoading('Carregando notas...');
                            try {
                                const url = '/api/notas';
                                console.log('Carregando notas de:', url);
                                const res = await fetch(url);
                                console.log('Status da resposta:', res.status);
                                const data = await res.json();
                                console.log('Dados recebidos:', data);

                                if (!data.success) {
                                    console.error('Erro da API:', data.message || data.error);
                                    mostrarToast('error', 'Erro ao Carregar', data.message || data.error || 'N√£o foi poss√≠vel carregar as notas');
                                    return;
                                }

                                this.notas = data.dados || [];
                                console.log(`‚úì ${this.notas.length} nota(s) carregada(s):`, this.notas);
                                this.processarNotas();
                            } catch (err) {
                                console.error('Erro ao carregar notas:', err);
                                mostrarToast('error', 'Erro ao Carregar', 'Ocorreu um erro ao carregar as notas');
                            } finally {
                                ocultarLoading();
                            }
                        },

                        // Processa e filtra notas
                        processarNotas() {
                            console.log('üîÑ Processando notas...');

                            // 1. Calcular dias restantes para cada nota
                            const notasComDias = this.notas.map(nota => {
                                let diasRestantes = null;
                                let prazoDate = null;

                                // Verificar se a nota √© resolvida ou cancelada
                                const statusNome = nota.status?.nome?.toLowerCase() || '';
                                const isResolvida = statusNome.includes('resolvid') || statusNome.includes('cancelad');

                                if (!isResolvida && nota.prazoFinal) {
                                    prazoDate = this.parseDataBrasileira(nota.prazoFinal);
                                    const hoje = new Date();
                                    hoje.setHours(0, 0, 0, 0);
                                    diasRestantes = Math.floor((prazoDate - hoje) / (1000 * 60 * 60 * 24));
                                }

                                console.log(`üìÖ Nota "${nota.titulo}": status="${nota.status?.nome}", prazoFinal="${nota.prazoFinal}", diasRestantes=${diasRestantes}`);

                                return {
                                    ...nota,
                                    diasRestantes,
                                    prazoDate
                                };
                            });

                            // 2. Filtrar por pesquisa
                            let notasFiltradas = notasComDias;
                            if (this.termoPesquisa.trim()) {
                                const termo = this.termoPesquisa.toLowerCase();
                                notasFiltradas = notasFiltradas.filter(nota =>
                                    nota.titulo.toLowerCase().includes(termo) ||
                                    (nota.conteudo && nota.conteudo.toLowerCase().includes(termo)) ||
                                    nota.etiqueta.nome.toLowerCase().includes(termo) ||
                                    nota.status.nome.toLowerCase().includes(termo)
                                );
                            }

                            // 3. Filtrar por etiqueta (dropdown - mantido para compatibilidade)
                            if (this.filtroEtiqueta) {
                                notasFiltradas = notasFiltradas.filter(n => n.etiqueta.id == this.filtroEtiqueta);
                            }

                            // 4. Filtrar por status (dropdown - mantido para compatibilidade)
                            if (this.filtroStatus) {
                                notasFiltradas = notasFiltradas.filter(n => n.status.id == this.filtroStatus);
                            }

                            // 5. Filtros m√∫ltiplos por etiquetas (badges)
                            if (this.filtrosAtivos.etiquetas.length > 0) {
                                notasFiltradas = notasFiltradas.filter(n =>
                                    this.filtrosAtivos.etiquetas.includes(n.etiqueta.id)
                                );
                            }

                            // 6. Filtros m√∫ltiplos por status (badges)
                            if (this.filtrosAtivos.status.length > 0) {
                                notasFiltradas = notasFiltradas.filter(n =>
                                    this.filtrosAtivos.status.includes(n.status.id)
                                );
                            }

                            // 7. Filtrar por intervalo de datas
                            if (this.filtroData.inicio && this.filtroData.fim) {
                                const dataInicio = new Date(this.filtroData.inicio);
                                const dataFim = new Date(this.filtroData.fim);
                                dataInicio.setHours(0, 0, 0, 0);
                                dataFim.setHours(23, 59, 59, 999);

                                notasFiltradas = notasFiltradas.filter(n => {
                                    const prazoNota = n.prazoDate;
                                    return prazoNota >= dataInicio && prazoNota <= dataFim;
                                });

                                console.log(`üìÖ Filtro de data aplicado: ${notasFiltradas.length} notas entre ${this.filtroData.inicio} e ${this.filtroData.fim}`);
                            }

                            // 8. Ordenar
                            notasFiltradas.sort((a, b) => {
                                let valorA, valorB;

                                switch(this.colunaOrdenacao) {
                                    case 'titulo':
                                        valorA = a.titulo.toLowerCase();
                                        valorB = b.titulo.toLowerCase();
                                        break;
                                    case 'etiqueta':
                                        valorA = a.etiqueta.nome.toLowerCase();
                                        valorB = b.etiqueta.nome.toLowerCase();
                                        break;
                                    case 'status':
                                        valorA = a.status.nome.toLowerCase();
                                        valorB = b.status.nome.toLowerCase();
                                        break;
                                    case 'prazo':
                                        valorA = a.prazoDate.getTime();
                                        valorB = b.prazoDate.getTime();
                                        break;
                                    case 'diasRestantes':
                                    default:
                                        // Tratar null: colocar no final
                                        valorA = a.diasRestantes !== null ? a.diasRestantes : Number.MAX_SAFE_INTEGER;
                                        valorB = b.diasRestantes !== null ? b.diasRestantes : Number.MAX_SAFE_INTEGER;
                                        break;
                                }

                                if (valorA < valorB) return this.direcaoOrdenacao === 'asc' ? -1 : 1;
                                if (valorA > valorB) return this.direcaoOrdenacao === 'asc' ? 1 : -1;
                                return 0;
                            });

                            this.notasProcessadas = notasFiltradas;

                            // 6. Gerar alertas urgentes
                            this.gerarAlertasUrgentes(notasComDias);
                        },

                        // Gera lista de alertas por prioridade
                        gerarAlertasUrgentes(notas) {
                            const alertas = [];

                            notas.forEach(nota => {
                                // Ignorar notas com status "Resolvido" ou "Cancelado"
                                const statusNome = nota.status?.nome?.toLowerCase() || '';
                                if (statusNome.includes('resolvid') || statusNome.includes('cancelad')) {
                                    return; // N√£o gera alerta para essas notas
                                }

                                let nivel, prazoTexto;
                                const dias = nota.diasRestantes;

                                // Pular notas sem diasRestantes (j√° resolvidas ou canceladas)
                                if (dias === null || dias === undefined) {
                                    return;
                                }

                                if (dias < 0) {
                                    nivel = 'CR√çTICO';
                                    prazoTexto = `Atrasada ${Math.abs(dias)} dia(s)`;
                                } else if (dias === 0) {
                                    nivel = 'CR√çTICO';
                                    prazoTexto = 'Vence HOJE';
                                } else if (dias === 1) {
                                    nivel = 'URGENTE';
                                    prazoTexto = 'Vence AMANH√É';
                                } else if (dias <= 3) {
                                    nivel = 'URGENTE';
                                    prazoTexto = `${dias} dias restantes`;
                                } else if (dias <= 5) {
                                    nivel = 'ATEN√á√ÉO';
                                    prazoTexto = `${dias} dias restantes`;
                                } else if (dias <= 7) {
                                    nivel = 'AVISO';
                                    prazoTexto = `${dias} dias restantes`;
                                } else {
                                    return; // N√£o inclui em alertas
                                }

                                alertas.push({
                                    id: nota.id,
                                    titulo: nota.titulo,
                                    nivel,
                                    prazoTexto,
                                    diasRestantes: dias
                                });
                            });

                            // Ordenar por urg√™ncia (dias restantes crescente)
                            alertas.sort((a, b) => a.diasRestantes - b.diasRestantes);

                            this.alertasUrgentes = alertas;
                            console.log(`üö® ${alertas.length} alerta(s) gerado(s):`, alertas);
                        },

                        // Parse data brasileira (dd/MM/yyyy, dd-MM-yyyy) ou ISO (yyyy-MM-dd)
                        parseDataBrasileira(dataStr) {
                            if (!dataStr) return new Date();

                            // Verifica se √© formato ISO (yyyy-MM-dd)
                            if (dataStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                                const partes = dataStr.split('-');
                                return new Date(partes[0], partes[1] - 1, partes[2]);
                            }

                            // Formato brasileiro com barras (dd/MM/yyyy)
                            if (dataStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                                const partes = dataStr.split('/');
                                return new Date(partes[2], partes[1] - 1, partes[0]);
                            }

                            // Formato brasileiro com h√≠fens (dd-MM-yyyy)
                            if (dataStr.match(/^\d{2}-\d{2}-\d{4}$/)) {
                                const partes = dataStr.split('-');
                                return new Date(partes[2], partes[1] - 1, partes[0]);
                            }

                            // Fallback: tenta criar Date diretamente
                            console.warn('Formato de data n√£o reconhecido:', dataStr);
                            return new Date(dataStr);
                        },

                        // Pesquisa com debounce
                        pesquisarNotas() {
                            clearTimeout(this.pesquisaTimeout);
                            this.pesquisaTimeout = setTimeout(() => {
                                this.processarNotas();
                            }, 300);
                        },

                        // Ordenar por coluna
                        ordenarPor(coluna) {
                            if (this.colunaOrdenacao === coluna) {
                                // Inverte dire√ß√£o se j√° est√° ordenando por essa coluna
                                this.direcaoOrdenacao = this.direcaoOrdenacao === 'asc' ? 'desc' : 'asc';
                            } else {
                                // Nova coluna, come√ßa com ascendente
                                this.colunaOrdenacao = coluna;
                                this.direcaoOrdenacao = 'asc';
                            }
                            this.processarNotas();
                        },

                        // √çcone de ordena√ß√£o
                        getSortIcon(coluna) {
                            if (this.colunaOrdenacao !== coluna) return '‚áÖ';
                            return this.direcaoOrdenacao === 'asc' ? '‚Üë' : '‚Üì';
                        },

                        // √çcone de alerta
                        getAlertaIcon(nivel) {
                            switch(nivel) {
                                case 'CR√çTICO': return 'üî¥';
                                case 'URGENTE': return 'üü†';
                                case 'ATEN√á√ÉO': return 'üü°';
                                case 'AVISO': return 'üîµ';
                                default: return '‚ö™';
                            }
                        },

                        async carregarEtiquetas() {
                            mostrarLoading('Carregando etiquetas...');
                            try {
                                const res = await fetch('/api/etiquetas');
                                const data = await res.json();
                                this.etiquetas = data.dados || [];
                                console.log('Etiquetas carregadas:', this.etiquetas.length);
                            } catch (err) {
                                console.error('Erro ao carregar etiquetas:', err);
                            } finally {
                                ocultarLoading();
                            }
                        },

                        async carregarStatus() {
                            mostrarLoading('Carregando status...');
                            try {
                                const res = await fetch('/api/status');
                                const data = await res.json();

                                console.log('Status carregados:', data);

                                if (!data.success) {
                                    console.error('Erro ao carregar status:', data.message);
                                    mostrarToast('error', 'Erro ao Carregar Status', data.message || 'N√£o foi poss√≠vel carregar os status');
                                    return;
                                }

                                this.statusList = data.dados || [];

                                if (this.statusList.length === 0) {
                                    console.warn('Nenhum status encontrado no banco de dados');
                                    return;
                                }

                                console.log('Status dispon√≠veis:', this.statusList.length);

                                console.log(`‚úì ${this.statusList.length} status carregados com sucesso`);
                            } catch (err) {
                                console.error('Erro ao carregar status:', err);
                                mostrarToast('error', 'Erro ao Carregar Status', 'Ocorreu um erro ao carregar os status');
                            } finally {
                                ocultarLoading();
                            }
                        },

                        // Alertas agora s√£o gerados localmente pela fun√ß√£o gerarAlertasUrgentes()
                        // que √© chamada automaticamente ao processar as notas

                        /**
                         * Abre modal de confirma√ß√£o para deletar nota
                         * @param {number} id - ID da nota a ser deletada
                         */
                        deletarNota(id) {
                            // Buscar a nota na lista processada
                            const nota = this.notasProcessadas.find(n => n.id === id);
                            if (nota) {
                                this.notaDeletar = nota;
                                this.modalConfirmarDeletar = true;
                            }
                        },

                        /**
                         * Confirma e executa a exclus√£o da nota
                         */
                        async confirmarDeletar() {
                            if (!this.notaDeletar) return;

                            const id = this.notaDeletar.id;
                            const titulo = this.notaDeletar.titulo;

                            mostrarLoading('Deletando nota...');
                            try {
                                const res = await fetch(`/api/notas/${id}`, { method: 'DELETE' });
                                const data = await res.json();

                                if (data.success) {
                                    mostrarToast('success', 'Nota Deletada', `"${titulo}" foi removida com sucesso!`);
                                    await this.carregarNotas();
                                } else {
                                    mostrarToast('error', 'Erro ao Deletar', data.message || 'N√£o foi poss√≠vel deletar a nota');
                                    ocultarLoading();
                                }
                            } catch (err) {
                                mostrarToast('error', 'Erro ao Deletar', 'Ocorreu um erro ao tentar deletar a nota');
                                console.error('Erro ao deletar nota:', err);
                                ocultarLoading();
                            } finally {
                                // Fechar modal
                                this.cancelarDeletar();
                            }
                        },

                        /**
                         * Cancela a exclus√£o e fecha o modal
                         */
                        cancelarDeletar() {
                            this.modalConfirmarDeletar = false;
                            setTimeout(() => {
                                this.notaDeletar = null;
                            }, 300);
                        },

                        /**
                         * ========================================
                         * DELE√á√ÉO EM MASSA
                         * ========================================
                         */

                        /**
                         * Abre modal de confirma√ß√£o para deletar notas selecionadas.
                         */
                        abrirModalDeletarSelecionadas() {
                            if (this.notasSelecionadas.length === 0) {
                                mostrarToast('warning', 'Nenhuma Nota Selecionada', 'Selecione ao menos uma nota para deletar');
                                return;
                            }

                            this.modalDeletarSelecionadas = true;
                            console.log(`üóëÔ∏è Modal de deletar selecionadas aberto. ${this.notasSelecionadas.length} nota(s) selecionada(s)`);
                        },

                        /**
                         * Fecha modal de confirma√ß√£o de deletar selecionadas.
                         */
                        fecharModalDeletarSelecionadas() {
                            this.modalDeletarSelecionadas = false;
                        },

                        /**
                         * Obt√©m o t√≠tulo de uma nota pelo ID.
                         * @param {number} notaId - ID da nota
                         * @returns {string} T√≠tulo da nota ou mensagem de erro
                         */
                        obterTituloNota(notaId) {
                            const nota = this.notas.find(n => n.id === notaId);
                            return nota ? nota.titulo : 'Nota n√£o encontrada';
                        },

                        /**
                         * Confirma e executa a exclus√£o de m√∫ltiplas notas selecionadas.
                         * Deleta as notas em paralelo e mostra progresso ao usu√°rio.
                         */
                        async confirmarDeletarSelecionadas() {
                            const quantidade = this.notasSelecionadas.length;

                            if (quantidade === 0) return;

                            this.fecharModalDeletarSelecionadas();
                            mostrarLoading(`Deletando ${quantidade} nota(s)...`);

                            try {
                                let sucessos = 0;
                                let erros = 0;

                                // Deletar notas em paralelo
                                const promises = this.notasSelecionadas.map(async (notaId) => {
                                    try {
                                        const res = await fetch(`/api/notas/${notaId}`, { method: 'DELETE' });
                                        const data = await res.json();

                                        if (data.success) {
                                            sucessos++;
                                            console.log(`‚úì Nota ID ${notaId} deletada com sucesso`);
                                        } else {
                                            erros++;
                                            console.error(`‚úó Erro ao deletar nota ID ${notaId}:`, data.message);
                                        }
                                    } catch (err) {
                                        erros++;
                                        console.error(`‚úó Exce√ß√£o ao deletar nota ID ${notaId}:`, err);
                                    }
                                });

                                // Aguardar todas as requisi√ß√µes
                                await Promise.all(promises);

                                // Limpar sele√ß√£o
                                this.notasSelecionadas = [];

                                // Recarregar lista de notas
                                await this.carregarNotas();

                                // Mostrar resultado
                                if (erros === 0) {
                                    mostrarToast('success', 'Notas Deletadas',
                                        `${sucessos} nota(s) deletada(s) com sucesso!`);
                                } else if (sucessos === 0) {
                                    mostrarToast('error', 'Erro ao Deletar',
                                        `N√£o foi poss√≠vel deletar nenhuma nota. ${erros} erro(s).`);
                                } else {
                                    mostrarToast('warning', 'Dele√ß√£o Parcial',
                                        `${sucessos} nota(s) deletada(s), ${erros} erro(s).`);
                                }

                                console.log(`üìä Resultado da dele√ß√£o em massa: ${sucessos} sucessos, ${erros} erros`);

                            } catch (err) {
                                mostrarToast('error', 'Erro ao Deletar', 'Ocorreu um erro ao deletar as notas');
                                console.error('Erro ao deletar notas em massa:', err);
                            } finally {
                                ocultarLoading();
                            }
                        },

                        /**
                         * ========================================
                         * MUDAR STATUS EM MASSA
                         * ========================================
                         */

                        /**
                         * Abre modal para mudar status das notas selecionadas.
                         */
                        abrirModalMudarStatus() {
                            if (this.notasSelecionadas.length === 0) {
                                mostrarToast('warning', 'Nenhuma Nota Selecionada', 'Selecione ao menos uma nota para mudar o status');
                                return;
                            }

                            this.novoStatusMassa = ''; // Limpar sele√ß√£o anterior
                            this.modalMudarStatus = true;
                            console.log(`üìä Modal de mudar status aberto. ${this.notasSelecionadas.length} nota(s) selecionada(s)`);
                        },

                        /**
                         * Fecha modal de mudar status.
                         */
                        fecharModalMudarStatus() {
                            this.modalMudarStatus = false;
                            this.novoStatusMassa = '';
                        },

                        /**
                         * Confirma e executa a mudan√ßa de status de m√∫ltiplas notas.
                         * Atualiza as notas em paralelo e mostra progresso ao usu√°rio.
                         */
                        async confirmarMudarStatus() {
                            const quantidade = this.notasSelecionadas.length;
                            const novoStatusId = parseInt(this.novoStatusMassa);

                            if (!novoStatusId) {
                                mostrarToast('warning', 'Status N√£o Selecionado', 'Por favor, selecione um status');
                                return;
                            }

                            if (quantidade === 0) return;

                            // Buscar nome do status selecionado
                            const statusObj = this.statusList.find(s => s.id === novoStatusId);
                            const nomeStatus = statusObj ? statusObj.nome : 'Status';

                            this.fecharModalMudarStatus();
                            mostrarLoading(`Atualizando status de ${quantidade} nota(s)...`);

                            try {
                                let sucessos = 0;
                                let erros = 0;

                                // Atualizar notas em paralelo
                                const promises = this.notasSelecionadas.map(async (notaId) => {
                                    try {
                                        // Buscar nota atual para manter outros dados
                                        const nota = this.notas.find(n => n.id === notaId);
                                        if (!nota) {
                                            erros++;
                                            console.error(`‚úó Nota ID ${notaId} n√£o encontrada`);
                                            return;
                                        }

                                        // Montar payload de atualiza√ß√£o
                                        const payload = {
                                            titulo: nota.titulo,
                                            conteudo: nota.conteudo,
                                            prazoFinal: nota.prazoFinal,
                                            etiquetaId: nota.etiqueta.id,
                                            statusId: novoStatusId
                                        };

                                        const res = await fetch(`/api/notas/${notaId}`, {
                                            method: 'PUT',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify(payload)
                                        });
                                        const data = await res.json();

                                        if (data.success) {
                                            sucessos++;
                                            console.log(`‚úì Status da nota ID ${notaId} atualizado para "${nomeStatus}"`);
                                        } else {
                                            erros++;
                                            console.error(`‚úó Erro ao atualizar nota ID ${notaId}:`, data.message);
                                        }
                                    } catch (err) {
                                        erros++;
                                        console.error(`‚úó Exce√ß√£o ao atualizar nota ID ${notaId}:`, err);
                                    }
                                });

                                // Aguardar todas as requisi√ß√µes
                                await Promise.all(promises);

                                // Limpar sele√ß√£o
                                this.notasSelecionadas = [];

                                // Recarregar lista de notas
                                await this.carregarNotas();

                                // Mostrar resultado
                                if (erros === 0) {
                                    mostrarToast('success', 'Status Atualizado',
                                        `Status de ${sucessos} nota(s) alterado para "${nomeStatus}"!`);
                                } else if (sucessos === 0) {
                                    mostrarToast('error', 'Erro ao Atualizar',
                                        `N√£o foi poss√≠vel atualizar nenhuma nota. ${erros} erro(s).`);
                                } else {
                                    mostrarToast('warning', 'Atualiza√ß√£o Parcial',
                                        `${sucessos} nota(s) atualizada(s), ${erros} erro(s).`);
                                }

                                console.log(`üìä Resultado da mudan√ßa de status em massa: ${sucessos} sucessos, ${erros} erros`);

                            } catch (err) {
                                mostrarToast('error', 'Erro ao Atualizar', 'Ocorreu um erro ao atualizar o status das notas');
                                console.error('Erro ao mudar status em massa:', err);
                            } finally {
                                ocultarLoading();
                            }
                        },

                        /**
                         * Exporta uma nota individual para PDF
                         * @param {number} notaId - ID da nota a ser exportada
                         * @param {string} tituloNota - T√≠tulo da nota (usado para nome do arquivo)
                         */
                        async gerarPDF(notaId, tituloNota) {
                            mostrarLoading('Gerando PDF...');
                            try {
                                console.log(`üìÑ Gerando PDF para nota ID: ${notaId}`);

                                // Fazer requisi√ß√£o para o endpoint de PDF
                                const response = await fetch(`/api/notas/${notaId}/pdf`);

                                if (!response.ok) {
                                    throw new Error(`Erro ao gerar PDF: ${response.statusText}`);
                                }

                                // Converter resposta em blob
                                const blob = await response.blob();

                                // Criar nome do arquivo limpo (sem caracteres especiais)
                                const nomeArquivo = tituloNota
                                    .replace(/[^a-zA-Z0-9\s-]/g, '') // Remove caracteres especiais
                                    .replace(/\s+/g, '_') // Substitui espa√ßos por underscore
                                    .substring(0, 50); // Limita tamanho

                                // Gerar timestamp no formato brasileiro (DDMMYYYY)
                                const agora = new Date();
                                const dia = String(agora.getDate()).padStart(2, '0');
                                const mes = String(agora.getMonth() + 1).padStart(2, '0');
                                const ano = agora.getFullYear();
                                const timestamp = `${dia}${mes}${ano}`;

                                const nomeCompleto = `Nota_${nomeArquivo}_${timestamp}.pdf`;

                                // Criar link tempor√°rio para download
                                const url = window.URL.createObjectURL(blob);
                                const link = document.createElement('a');
                                link.href = url;
                                link.download = nomeCompleto;
                                document.body.appendChild(link);
                                link.click();

                                // Limpar
                                document.body.removeChild(link);
                                window.URL.revokeObjectURL(url);

                                console.log(`‚úì PDF gerado com sucesso: ${nomeCompleto}`);

                                // Feedback visual com toast
                                mostrarToast('success', 'PDF Exportado', 'Nota exportada com sucesso!');

                            } catch (error) {
                                console.error('‚ùå Erro ao gerar PDF:', error);
                                mostrarToast('error', 'Erro ao Exportar', `N√£o foi poss√≠vel gerar o PDF: ${error.message}`);
                            } finally {
                                ocultarLoading();
                            }
                        },

                        /**
                         * Alterna a sele√ß√£o de uma nota individual
                         * @param {number} notaId - ID da nota a ser selecionada/desselecionada
                         */
                        toggleSelecaoNota(notaId) {
                            const index = this.notasSelecionadas.indexOf(notaId);
                            if (index === -1) {
                                // Nota n√£o est√° selecionada, adicionar
                                this.notasSelecionadas.push(notaId);
                                console.log(`‚úì Nota ${notaId} selecionada. Total: ${this.notasSelecionadas.length}`);
                            } else {
                                // Nota j√° est√° selecionada, remover
                                this.notasSelecionadas.splice(index, 1);
                                console.log(`‚úó Nota ${notaId} desselecionada. Total: ${this.notasSelecionadas.length}`);
                            }
                        },

                        /**
                         * Verifica se uma nota est√° selecionada
                         * @param {number} notaId - ID da nota
                         * @returns {boolean} true se a nota est√° selecionada
                         */
                        notaEstaSelecionada(notaId) {
                            return this.notasSelecionadas.includes(notaId);
                        },

                        /**
                         * Alterna entre selecionar todas as notas vis√≠veis ou desselecionar todas
                         */
                        toggleSelecionarTodas() {
                            if (this.todasNotasSelecionadas()) {
                                // Desselecionar todas
                                this.notasSelecionadas = [];
                                console.log('‚úó Todas as notas desselecionadas');
                            } else {
                                // Selecionar todas as notas vis√≠veis (processadas)
                                this.notasSelecionadas = this.notasProcessadas.map(nota => nota.id);
                                console.log(`‚úì ${this.notasSelecionadas.length} notas selecionadas`);
                            }
                        },

                        /**
                         * Verifica se todas as notas vis√≠veis est√£o selecionadas
                         * @returns {boolean} true se todas as notas processadas est√£o selecionadas
                         */
                        todasNotasSelecionadas() {
                            if (this.notasProcessadas.length === 0) return false;
                            return this.notasProcessadas.every(nota => this.notasSelecionadas.includes(nota.id));
                        },

                        /**
                         * Exporta m√∫ltiplas notas selecionadas para um √∫nico PDF (relat√≥rio)
                         * Faz POST para /api/notas/pdf/relatorio com array de IDs
                         */
                        async exportarSelecionadas() {
                            if (this.notasSelecionadas.length === 0) {
                                mostrarToast('warning', 'Nenhuma Sele√ß√£o', 'Selecione pelo menos uma nota para exportar');
                                return;
                            }

                            mostrarLoading(`Gerando relat√≥rio com ${this.notasSelecionadas.length} nota(s)...`);
                            try {
                                console.log(`üìä Exportando ${this.notasSelecionadas.length} nota(s) selecionada(s)`);

                                // Fazer requisi√ß√£o POST com array de IDs
                                const response = await fetch('/api/notas/pdf/relatorio', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        ids: this.notasSelecionadas
                                    })
                                });

                                if (!response.ok) {
                                    throw new Error(`Erro ao gerar PDF: ${response.statusText}`);
                                }

                                // Converter resposta em blob
                                const blob = await response.blob();

                                // Gerar timestamp no formato brasileiro (DDMMYYYY_HHmmss)
                                const agora = new Date();
                                const dia = String(agora.getDate()).padStart(2, '0');
                                const mes = String(agora.getMonth() + 1).padStart(2, '0');
                                const ano = agora.getFullYear();
                                const hora = String(agora.getHours()).padStart(2, '0');
                                const min = String(agora.getMinutes()).padStart(2, '0');
                                const seg = String(agora.getSeconds()).padStart(2, '0');
                                const timestamp = `${dia}${mes}${ano}_${hora}${min}${seg}`;

                                const nomeCompleto = `Relatorio_Notas_${timestamp}.pdf`;

                                // Criar link tempor√°rio para download
                                const url = window.URL.createObjectURL(blob);
                                const link = document.createElement('a');
                                link.href = url;
                                link.download = nomeCompleto;
                                document.body.appendChild(link);
                                link.click();

                                // Limpar
                                document.body.removeChild(link);
                                window.URL.revokeObjectURL(url);

                                console.log(`‚úì Relat√≥rio PDF gerado com sucesso: ${nomeCompleto}`);

                                // Limpar sele√ß√£o ap√≥s exporta√ß√£o bem-sucedida
                                const quantidadeExportada = this.notasSelecionadas.length;
                                this.notasSelecionadas = [];
                                console.log('‚úì Sele√ß√£o limpa ap√≥s exporta√ß√£o');

                                // Feedback visual com toast
                                mostrarToast('success', 'Relat√≥rio Gerado', `${quantidadeExportada} nota(s) exportada(s) com sucesso!`);

                            } catch (error) {
                                console.error('‚ùå Erro ao exportar notas selecionadas:', error);
                                mostrarToast('error', 'Erro ao Exportar Relat√≥rio', `N√£o foi poss√≠vel gerar o PDF: ${error.message}`);
                            } finally {
                                ocultarLoading();
                            }
                        },

                        abrirModalEtiquetas() {
                            this.modalEtiquetas = true;
                        },

                        async salvarEtiqueta() {
                            mostrarLoading('Salvando etiqueta...');
                            try {
                                // Se estiver editando, fazer PUT; sen√£o, fazer POST
                                const url = this.etiquetaEditandoId
                                    ? `/api/etiquetas/${this.etiquetaEditandoId}`
                                    : '/api/etiquetas';
                                const method = this.etiquetaEditandoId ? 'PUT' : 'POST';
                                const acao = this.etiquetaEditandoId ? 'atualizada' : 'criada';

                                const res = await fetch(url, {
                                    method: method,
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ nome: this.novaEtiqueta })
                                });
                                const data = await res.json();
                                if (data.success) {
                                    mostrarToast('success', 'Etiqueta Salva', `Etiqueta ${acao} com sucesso!`);
                                    this.novaEtiqueta = '';
                                    this.etiquetaEditandoId = null;
                                    await this.carregarEtiquetas();
                                    await this.carregarNotas(); // Recarregar notas para atualizar badges
                                } else {
                                    mostrarToast('error', 'Erro ao Salvar', data.message || 'N√£o foi poss√≠vel salvar a etiqueta');
                                }
                            } catch (err) {
                                mostrarToast('error', 'Erro ao Salvar', 'Ocorreu um erro ao salvar a etiqueta');
                                console.error('Erro ao salvar etiqueta:', err);
                            } finally {
                                ocultarLoading();
                            }
                        },

                        async deletarEtiqueta(id) {
                            if (!confirm('Deletar esta etiqueta? Todas as notas associadas tamb√©m ser√£o deletadas!')) return;
                            mostrarLoading('Deletando etiqueta...');
                            try {
                                const res = await fetch(`/api/etiquetas/${id}`, { method: 'DELETE' });
                                const data = await res.json();
                                if (data.success) {
                                    mostrarToast('success', 'Etiqueta Deletada', data.message || 'Etiqueta removida com sucesso!');
                                    await this.carregarEtiquetas();
                                    await this.carregarNotas();
                                } else {
                                    mostrarToast('error', 'Erro ao Deletar', data.message || 'N√£o foi poss√≠vel deletar a etiqueta');
                                }
                            } catch (err) {
                                mostrarToast('error', 'Erro ao Deletar', 'Ocorreu um erro ao deletar a etiqueta');
                                console.error('Erro ao deletar etiqueta:', err);
                            } finally {
                                ocultarLoading();
                            }
                        },

                        fecharModalEtiquetas() {
                            this.modalEtiquetas = false;
                            this.cancelarEdicaoEtiqueta();
                        },

                        iniciarEdicaoEtiqueta(etiqueta) {
                            this.etiquetaEditandoId = etiqueta.id;
                            this.novaEtiqueta = etiqueta.nome;
                        },

                        cancelarEdicaoEtiqueta() {
                            this.etiquetaEditandoId = null;
                            this.novaEtiqueta = '';
                        },

                        abrirModalStatus() {
                            this.modalStatus = true;
                        },

                        async salvarStatus() {
                            mostrarLoading('Salvando status...');
                            try {
                                // Se estiver editando, fazer PUT; sen√£o, fazer POST
                                const url = this.statusEditandoId
                                    ? `/api/status/${this.statusEditandoId}`
                                    : '/api/status';
                                const method = this.statusEditandoId ? 'PUT' : 'POST';
                                const acao = this.statusEditandoId ? 'atualizado' : 'criado';

                                console.log('Salvando status:', { nome: this.novoStatus.nome, corHex: this.novoStatus.cor, method });
                                const res = await fetch(url, {
                                    method: method,
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ nome: this.novoStatus.nome, corHex: this.novoStatus.cor })
                                });
                                const data = await res.json();
                                console.log('Resposta do servidor:', data);
                                if (data.success) {
                                    mostrarToast('success', 'Status Salvo', `Status ${acao} com sucesso!`);
                                    this.novoStatus = { nome: '', cor: '#6B7280' };
                                    this.statusEditandoId = null;
                                    await this.carregarStatus();
                                    await this.carregarNotas(); // Recarregar notas para atualizar badges
                                } else {
                                    mostrarToast('error', 'Erro ao Salvar', data.message || 'N√£o foi poss√≠vel salvar o status');
                                }
                            } catch (err) {
                                console.error('Erro ao salvar:', err);
                                mostrarToast('error', 'Erro ao Salvar', 'Ocorreu um erro ao salvar o status');
                            } finally {
                                ocultarLoading();
                            }
                        },

                        async deletarStatus(id) {
                            if (!confirm('Deseja realmente deletar este status?')) return;
                            mostrarLoading('Deletando status...');
                            try {
                                const res = await fetch(`/api/status/${id}`, { method: 'DELETE' });
                                const data = await res.json();
                                if (data.success) {
                                    mostrarToast('success', 'Status Deletado', data.message || 'Status removido com sucesso!');
                                    await this.carregarStatus();
                                } else {
                                    mostrarToast('error', 'Erro ao Deletar', data.message || 'N√£o foi poss√≠vel deletar o status');
                                }
                            } catch (err) {
                                mostrarToast('error', 'Erro ao Deletar', 'Ocorreu um erro ao deletar o status');
                                console.error('Erro ao deletar status:', err);
                            } finally {
                                ocultarLoading();
                            }
                        },

                        fecharModalStatus() {
                            this.modalStatus = false;
                            this.cancelarEdicaoStatus();
                        },

                        /**
                         * Abre modal de preview para visualizar nota
                         * @param {number} notaId - ID da nota a ser visualizada
                         */
                        async visualizarNota(notaId) {
                            mostrarLoading('Carregando nota...');
                            try {
                                console.log(`üëÅÔ∏è Abrindo preview da nota ID: ${notaId}`);

                                // Buscar dados da nota via API
                                const res = await fetch(`/api/notas/${notaId}`);
                                const data = await res.json();

                                if (!data.success) {
                                    mostrarToast('error', 'Erro ao Carregar', 'N√£o foi poss√≠vel carregar a nota');
                                    return;
                                }

                                // Armazenar nota e abrir modal
                                this.notaPreview = data.dados;
                                this.modalPreview = true;

                                console.log('‚úì Nota carregada para preview:', this.notaPreview);

                            } catch (err) {
                                console.error('Erro ao visualizar nota:', err);
                                mostrarToast('error', 'Erro ao Visualizar', 'Ocorreu um erro ao carregar a nota');
                            } finally {
                                ocultarLoading();
                            }
                        },

                        /**
                         * Fecha modal de preview
                         */
                        fecharModalPreview() {
                            this.modalPreview = false;
                            // Limpar dados ap√≥s anima√ß√£o de fechamento
                            setTimeout(() => {
                                this.notaPreview = null;
                            }, 300);
                        },

                        /**
                         * Exporta PDF da nota que est√° em preview
                         */
                        async exportarPDFPreview() {
                            if (!this.notaPreview) return;
                            await this.gerarPDF(this.notaPreview.id, this.notaPreview.titulo);
                        },

                        /**
                         * Verifica se h√° alertas cr√≠ticos (atrasados ou vencendo hoje)
                         * @returns {boolean} true se houver alertas cr√≠ticos
                         */
                        temAlertasCriticos() {
                            return this.alertasUrgentes.some(alerta => alerta.diasRestantes <= 0);
                        },

                        abrirModalAlertas() {
                            this.modalAlertas = true;
                        },

                        fecharModalAlertas() {
                            this.modalAlertas = false;
                        },

                        iniciarEdicaoStatus(status) {
                            this.statusEditandoId = status.id;
                            this.novoStatus.nome = status.nome;
                            this.novoStatus.cor = status.corHex;
                        },

                        cancelarEdicaoStatus() {
                            this.statusEditandoId = null;
                            this.novoStatus = { nome: '', cor: '#6B7280' };
                        },

                        getBadgeClass(dias) {
                            // Notas resolvidas ou canceladas n√£o t√™m badge de urg√™ncia
                            if (dias === null || dias === undefined) return '';
                            if (dias < 0) return 'badge-critico';
                            if (dias <= 1) return 'badge-urgente';
                            if (dias <= 3) return 'badge-atencao';
                            if (dias <= 5) return 'badge-aviso';
                            return '';
                        },

                        getDiasPrazoText(nota) {
                            const dias = nota.diasRestantes;
                            // Notas resolvidas ou canceladas n√£o t√™m diasRestantes calculado
                            if (dias === null || dias === undefined) return '-';
                            if (dias < 0) return `Atrasada ${Math.abs(dias)} dia(s)`;
                            if (dias === 0) return 'Vence HOJE';
                            if (dias === 1) return 'Vence AMANH√É';
                            return `${dias} dias restantes`;
                        },

                        /**
                         * Calcula a cor do texto (branco ou preto) baseado na lumin√¢ncia da cor de fundo
                         * para garantir contraste adequado.
                         *
                         * @param {string} hexColor - Cor em formato hexadecimal (#RRGGBB)
                         * @returns {string} 'white' ou 'black'
                         */
                        getContrastColor(hexColor) {
                            if (!hexColor) return 'white';

                            // Remove o # se existir
                            const hex = hexColor.replace('#', '');

                            // Converte para RGB
                            const r = parseInt(hex.substr(0, 2), 16);
                            const g = parseInt(hex.substr(2, 2), 16);
                            const b = parseInt(hex.substr(4, 2), 16);

                            // Calcula a lumin√¢ncia relativa usando a f√≥rmula WCAG
                            // https://www.w3.org/TR/WCAG20/#relativeluminancedef
                            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

                            // Se a lumin√¢ncia for maior que 0.5, usar texto escuro; sen√£o, usar texto claro
                            return luminance > 0.5 ? 'black' : 'white';
                        },

                        /**
                         * ========================================
                         * FILTROS VISUAIS COM BADGES
                         * ========================================
                         */

                        /**
                         * Alterna filtro de etiqueta (permite m√∫ltiplas sele√ß√µes).
                         * @param {number} etiquetaId - ID da etiqueta
                         */
                        toggleFiltroEtiqueta(etiquetaId) {
                            const index = this.filtrosAtivos.etiquetas.indexOf(etiquetaId);
                            if (index > -1) {
                                // Remove filtro
                                this.filtrosAtivos.etiquetas.splice(index, 1);
                                console.log(`üè∑Ô∏è Filtro de etiqueta ${etiquetaId} removido`);
                            } else {
                                // Adiciona filtro
                                this.filtrosAtivos.etiquetas.push(etiquetaId);
                                console.log(`üè∑Ô∏è Filtro de etiqueta ${etiquetaId} adicionado`);
                            }
                            this.processarNotas();
                        },

                        /**
                         * Alterna filtro de status (permite m√∫ltiplas sele√ß√µes).
                         * @param {number} statusId - ID do status
                         */
                        toggleFiltroStatus(statusId) {
                            const index = this.filtrosAtivos.status.indexOf(statusId);
                            if (index > -1) {
                                // Remove filtro
                                this.filtrosAtivos.status.splice(index, 1);
                                console.log(`üìä Filtro de status ${statusId} removido`);
                            } else {
                                // Adiciona filtro
                                this.filtrosAtivos.status.push(statusId);
                                console.log(`üìä Filtro de status ${statusId} adicionado`);
                            }
                            this.processarNotas();
                        },

                        /**
                         * Verifica se um filtro de etiqueta est√° ativo.
                         * @param {number} etiquetaId - ID da etiqueta
                         * @returns {boolean} true se o filtro est√° ativo
                         */
                        filtroEtiquetaAtivo(etiquetaId) {
                            return this.filtrosAtivos.etiquetas.includes(etiquetaId);
                        },

                        /**
                         * Verifica se um filtro de status est√° ativo.
                         * @param {number} statusId - ID do status
                         * @returns {boolean} true se o filtro est√° ativo
                         */
                        filtroStatusAtivo(statusId) {
                            return this.filtrosAtivos.status.includes(statusId);
                        },

                        /**
                         * Conta quantas notas t√™m determinada etiqueta (considerando filtros ativos).
                         * @param {number} etiquetaId - ID da etiqueta
                         * @returns {number} quantidade de notas
                         */
                        contarNotasPorEtiqueta(etiquetaId) {
                            return this.notas.filter(n => n.etiqueta.id === etiquetaId).length;
                        },

                        /**
                         * Conta quantas notas t√™m determinado status (considerando filtros ativos).
                         * @param {number} statusId - ID do status
                         * @returns {number} quantidade de notas
                         */
                        contarNotasPorStatus(statusId) {
                            return this.notas.filter(n => n.status.id === statusId).length;
                        },

                        /**
                         * Limpa todos os filtros de etiquetas.
                         */
                        limparFiltrosEtiquetas() {
                            this.filtrosAtivos.etiquetas = [];
                            console.log('üè∑Ô∏è Filtros de etiquetas limpos');
                            this.processarNotas();
                        },

                        /**
                         * Limpa todos os filtros de status.
                         */
                        limparFiltrosStatus() {
                            this.filtrosAtivos.status = [];
                            console.log('üìä Filtros de status limpos');
                            this.processarNotas();
                        },

                        /**
                         * Limpa todos os filtros (etiquetas e status).
                         */
                        limparTodosFiltros() {
                            this.filtrosAtivos.etiquetas = [];
                            this.filtrosAtivos.status = [];
                            console.log('‚ú® Todos os filtros limpos');
                            mostrarToast('info', 'Filtros Limpos', 'Todos os filtros foram removidos');
                            this.processarNotas();
                        },

                        /**
                         * ========================================
                         * FILTRO POR INTERVALO DE DATAS
                         * ========================================
                         */

                        /**
                         * Aplica filtro por intervalo de datas.
                         * Filtra notas cujo prazo final est√° entre as datas especificadas.
                         */
                        aplicarFiltroData() {
                            this.presetAtivo = ''; // Limpar preset se usu√°rio alterar datas manualmente
                            this.processarNotas();

                            if (this.filtroData.inicio && this.filtroData.fim) {
                                const dataInicioFormatada = new Date(this.filtroData.inicio).toLocaleDateString('pt-BR');
                                const dataFimFormatada = new Date(this.filtroData.fim).toLocaleDateString('pt-BR');
                                mostrarToast('info', 'Filtro de Data Aplicado',
                                    `Mostrando notas de ${dataInicioFormatada} at√© ${dataFimFormatada}`);
                            }
                        },

                        /**
                         * Limpa filtro por intervalo de datas.
                         */
                        limparFiltroData() {
                            this.filtroData.inicio = '';
                            this.filtroData.fim = '';
                            this.presetAtivo = '';
                            console.log('‚ú® Filtro de data limpo');
                            mostrarToast('info', 'Filtro de Data Limpo', 'Filtro por prazo removido');
                            this.processarNotas();
                        },

                        /**
                         * Aplica preset de intervalo de data.
                         * @param {string} preset - Nome do preset (hoje, esta-semana, este-mes, proximos-7-dias, proximos-30-dias)
                         */
                        aplicarPreset(preset) {
                            const hoje = new Date();
                            hoje.setHours(0, 0, 0, 0);

                            let dataInicio = new Date(hoje);
                            let dataFim = new Date(hoje);

                            switch (preset) {
                                case 'hoje':
                                    // In√≠cio e fim s√£o hoje
                                    break;

                                case 'esta-semana':
                                    // Do domingo ao s√°bado da semana atual
                                    const diaSemana = hoje.getDay();
                                    dataInicio = new Date(hoje);
                                    dataInicio.setDate(hoje.getDate() - diaSemana);
                                    dataFim = new Date(dataInicio);
                                    dataFim.setDate(dataInicio.getDate() + 6);
                                    break;

                                case 'este-mes':
                                    // Do dia 1 ao √∫ltimo dia do m√™s atual
                                    dataInicio = new Date(hoje.getFullYear(), hoje.getMonth(), 1);
                                    dataFim = new Date(hoje.getFullYear(), hoje.getMonth() + 1, 0);
                                    break;

                                case 'proximos-7-dias':
                                    // De hoje at√© 7 dias √† frente
                                    dataFim = new Date(hoje);
                                    dataFim.setDate(hoje.getDate() + 7);
                                    break;

                                case 'proximos-30-dias':
                                    // De hoje at√© 30 dias √† frente
                                    dataFim = new Date(hoje);
                                    dataFim.setDate(hoje.getDate() + 30);
                                    break;
                            }

                            // Formatar datas para input type="date" (yyyy-MM-dd)
                            this.filtroData.inicio = dataInicio.toISOString().split('T')[0];
                            this.filtroData.fim = dataFim.toISOString().split('T')[0];
                            this.presetAtivo = preset;

                            console.log(`üìÖ Preset aplicado: ${preset} (${this.filtroData.inicio} - ${this.filtroData.fim})`);
                            this.processarNotas();

                            // Mostrar toast com informa√ß√£o do preset
                            const presetNomes = {
                                'hoje': 'Hoje',
                                'esta-semana': 'Esta Semana',
                                'este-mes': 'Este M√™s',
                                'proximos-7-dias': 'Pr√≥ximos 7 Dias',
                                'proximos-30-dias': 'Pr√≥ximos 30 Dias'
                            };
                            mostrarToast('info', 'Preset Aplicado', `Filtro: ${presetNomes[preset]}`);
                        },

                        /**
                         * ========================================
                         * ATALHOS DE TECLADO
                         * ========================================
                         */

                        /**
                         * Configura atalhos de teclado globais para melhorar a navega√ß√£o.
                         *
                         * Atalhos dispon√≠veis:
                         * - Ctrl+N ou Alt+N: Nova nota
                         * - Esc: Fechar modais
                         * - /: Focar no campo de busca
                         * - Ctrl+L: Limpar todos os filtros
                         */
                        setupKeyboardShortcuts() {
                            document.addEventListener('keydown', (e) => {
                                // Ignorar atalhos se estiver digitando em um input/textarea (exceto atalhos espec√≠ficos)
                                const isTyping = ['INPUT', 'TEXTAREA'].includes(e.target.tagName);

                                // Ctrl+N ou Alt+N: Nova nota
                                if ((e.ctrlKey || e.altKey) && e.key.toLowerCase() === 'n') {
                                    e.preventDefault();
                                    console.log('‚å®Ô∏è Atalho: Nova Nota');
                                    window.location.href = '/notas/nova';
                                    return;
                                }

                                // Esc: Fechar modais
                                if (e.key === 'Escape') {
                                    console.log('‚å®Ô∏è Atalho: ESC - Fechando modais');

                                    if (this.modalEtiquetas) {
                                        this.fecharModalEtiquetas();
                                    } else if (this.modalStatus) {
                                        this.fecharModalStatus();
                                    } else if (this.modalAlertas) {
                                        this.fecharModalAlertas();
                                    } else if (this.modalPreview) {
                                        this.fecharModalPreview();
                                    } else if (this.modalConfirmarDeletar) {
                                        this.cancelarDeletar();
                                    } else if (this.mostrarControlesColunas) {
                                        this.mostrarControlesColunas = false;
                                    }
                                    return;
                                }

                                // / : Focar no campo de busca (apenas se n√£o estiver digitando)
                                if (e.key === '/' && !isTyping) {
                                    e.preventDefault();
                                    console.log('‚å®Ô∏è Atalho: / - Foco na busca');
                                    const searchInput = document.querySelector('input[placeholder*="Pesquisar"]');
                                    if (searchInput) {
                                        searchInput.focus();
                                        searchInput.select();
                                    }
                                    return;
                                }

                                // Ctrl+L: Limpar todos os filtros
                                if (e.ctrlKey && e.key.toLowerCase() === 'l') {
                                    e.preventDefault();
                                    console.log('‚å®Ô∏è Atalho: Ctrl+L - Limpar filtros');
                                    if (this.filtrosAtivos.etiquetas.length > 0 || this.filtrosAtivos.status.length > 0) {
                                        this.limparTodosFiltros();
                                    } else {
                                        mostrarToast('info', 'Nenhum Filtro', 'N√£o h√° filtros ativos para limpar');
                                    }
                                    return;
                                }

                                // Ctrl+A: Abrir modal de alertas
                                if (e.ctrlKey && e.key.toLowerCase() === 'a' && !isTyping) {
                                    e.preventDefault();
                                    console.log('‚å®Ô∏è Atalho: Ctrl+A - Alertas');
                                    this.abrirModalAlertas();
                                    return;
                                }

                                // Ctrl+E: Abrir modal de etiquetas
                                if (e.ctrlKey && e.key.toLowerCase() === 'e' && !isTyping) {
                                    e.preventDefault();
                                    console.log('‚å®Ô∏è Atalho: Ctrl+E - Etiquetas');
                                    this.abrirModalEtiquetas();
                                    return;
                                }

                                // Ctrl+T: Abrir modal de status
                                if (e.ctrlKey && e.key.toLowerCase() === 't' && !isTyping) {
                                    e.preventDefault();
                                    console.log('‚å®Ô∏è Atalho: Ctrl+T - Status');
                                    this.abrirModalStatus();
                                    return;
                                }
                            });

                            console.log('‚å®Ô∏è Atalhos de teclado configurados');
                            console.log('üìã Atalhos dispon√≠veis:');
                            console.log('   ‚Ä¢ Ctrl+N ou Alt+N: Nova nota');
                            console.log('   ‚Ä¢ Esc: Fechar modais');
                            console.log('   ‚Ä¢ /: Focar no campo de busca');
                            console.log('   ‚Ä¢ Ctrl+L: Limpar todos os filtros');
                            console.log('   ‚Ä¢ Ctrl+A: Abrir alertas');
                            console.log('   ‚Ä¢ Ctrl+E: Abrir etiquetas');
                            console.log('   ‚Ä¢ Ctrl+T: Abrir status');
                        }
                    }
                }
            </script>
        </div>
    </th:block>
</body>
</html>
